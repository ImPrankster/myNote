1.作用域和闭包
  传统语言编译步骤：分词/词法分析 解析/语法分析 代码生成
  JS保证性能最佳方法：JIT 延迟编译 重编译
  引擎：负责JS编译执行过程
  编译器：语法分析代码生成
  作用域：收集维护所有声明的标识符（变量）组成的一系列查询 并实施一套严格的规则 确定当前执行的代码对这些标识符的访问权限
  var赋值流程：分解成词法单元 词法单位生成一个树结构 判断作用域下是否有相同名称变量 新建变量 生成代码
  引擎查询：LHS、RHS
  LHS：向左查询，试图找到变量容器本身从而进行赋值 赋值操作的目标是谁
  RHS：向右查询，找到变量，非左侧（retrieve his source value）赋值操作的源头
  严格模式禁止LHS找不到的时候创建变量
2.词法作用域
  作用域气泡的结构和相互之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符的位置
  遮蔽效应：会在查找到第一个匹配的标识符的时候结束，所以不同作用域可以定义同名变量
  函数作用域只和声明时的位置有关
  词法作用域只会查找一级标识符，找到变量后对象属性访问规则会分别接管对象内属性的访问
  eval欺骗作用域，包含声明时，会修改所在位置的作用域
  JS定时器第一个参数可以是字符串（不推荐使用）
  new Function（ ）也可以传递字符串语句
  with通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身，没有完全隔离的语法作用域，因此容易造成作用域泄漏
  JS引擎会在编译阶段进行数项性能优化，其中某些优化依赖于能根据代码的词法进行静态分析，并预先确定函数和变量的定义位置，才能快速找到标识符，因此扰乱作用域会使这些优化白做功
3.函数作用域和块作用域
  函数作用域是指属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域也可以使用），能充分利用JS变量可以根据需要改变值类型的动态特性
  函数作用域的好处：隐藏内部实现，规避冲突
  函数作用域的问题：自身函数命名污染作用域，解决：自执行函数
  PS：如果函数是声明第一个词是函数声明，否则就是函数表达式
  匿名函数缺点：在栈追踪中不会显示有意义用户名，调试困难、如果没有函数名，需要引用自身时只能用arguments.callee引用、省略了函数名降低了可读性
  自执行函数：因为函数本身被包裹在（）中，所以是一个表达式，第二个（）立即执行这个函数
  let：绑定变量到当前作用域
  垃圾回收：let 可以避免闭包产生的阻拦垃圾回收的问题
  for循环头的let不仅将i绑定到for循环块中，事实上它将其重新绑定在循环的每一个迭代中，确保使用上一个迭代结束时的值进行重新赋值
4.提升
  引擎会在解释JS代码之前首先进行编译，编译的一部分工作就是找到所有的声明，并用合适的作用域关联起来
  只有声明本身会被提前，赋值和其他代码不变，每个作用域都会提升操作。
  函数和变量都会提升，并且函数会被首先提升，然后才是变量，并且应该避免块作用域内声明函数
5.作用域闭包
  当函数可以记住并访问所在词法作用域时，就产生了闭包，即使函数在当前词法作用域外执行
  通过闭包访问引用返回的函数，函数所在的作用域不会被引擎销毁。
  模块模式的必要特点：必须要有外部的封闭函数，该函数至少要被调用一次（每次调用都会创建一个新的模块）、封闭函数必须要返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并可以访问或者修改内部状态
  一个具有函数属性的对象本身并不是真正的模块，从方便观察角度看，一个函数调用所返回的，只有数据属性没有闭包函数的对象并不是真正的模块
  import可以将一个模块中的一个或多个API倒入当前作用域中，并分别绑定在一个变量上
  module会将整个模块的API倒入并绑定在一个变量上
  export会将当前模块的一个标识符导出为公共API
  模块化的特征：为创建内部作用域而了一个包装函数、包装函数的返回值必须至少包括一个对函数内部的引用
6.this
  this提供了一种更优雅的方式来隐式传递一个对象引用，因此可以将API设计得更加简洁并易于复用。
  arguments.callee可以引用当前运行的函数对象（已弃用）
  this是运行时绑定的，上下文取决于函数调用的条件，this声明和函数定义没有任何关系，只取决于函数调用方式，传入参数等信息，this就是记录其中一个属性，会在函数执行中调用
  默认绑定：直接使用不带修饰的函数调用
  隐式绑定：调用时有上下文对象或者被某个对象拥有或包含
  显式绑定：call apply bind 第一个参数如果传入了原始值，那么会被转换成对象形式（new String（））
        function bind(fn,obj){
          return function(){
            return fn.apply(obj,arguments)
          }
        }
    API调用的上下文：api通过传入参数实现回调函数指定this
  new绑定：JS特殊的构造函数只是一些使用new操作符时调用的函数，不属于某个类，也不会实例化一个类，实际上甚至不能说是一种特殊的函数类型，只是被new调用的普通函数。被称为构造函数调用（不存在构造函数 只有构造调用）
  new调用函数的步骤：
    1.创建一个全新的对象
    2.绑定原型给这个对象
    3.绑定this
    4.如果没有返回其他对象，那么new会自动返回这个对象
  优先级：默认绑定<隐式绑定<显式绑定<new
  polyfill处理旧浏览器的兼容问题，比如bind，但是因为不是内置函数无法创建不含.prototype的函数，会有一些副作用

          this.instanceof FNOP&&
          oThis?this:oThis
          //以及
          FNOP.prototype = this.prototype
          fBound.prototype = new FNOP
  这段代码会判断函数是否被new调用，如果是就会用新创建的this替代已有的this
  使用new的原因：主要目的是预先设置函数的一些参数，这样使用new进行初始化就可以只传入剩余参数
  bind的功能之一就是把第一个参数this外的其他参数都传给下层函数（柯里化的一种）
  判断this
  可以通过优先级来判断函数在某个调用位置应用的是哪条规则,按照下面的顺序进行判断
     1.函数是否在new中调用(new绑定)?如果是的话this绑定的是新创建的对象
     2.函数是否通过apply/call(显式绑定)或者硬绑定调用?如果是的话,this绑定的是指定的对象
     3.函数是否在某个上下文对象中调用(隐式绑定)?如果是的话,this绑定的是那个上下文对象
     4.如果都不是的话,使用默认绑定,如果在严格模式下,就绑定undefined,否则绑定全局对象
  例外:
     如果把null或者undefined传入call,会被忽略,并把this默认绑定(用apply展开数组用...替代)
  更安全的this:
     Object.create(null)创建一个空对象(不会创建prototype)然后作为this传入call/apply/bind
  间接引用
      function foo(){
        console.log(this.a)
      }
      var a = 2
      var o = { a: 3, foo: foo }
      var p = { a: 4 }
      o.foo() // 3
      (p.foo = o.foo)() // 2
  软绑定:
      if(!Function.prototype.softBind){
        Function.prototype.softBind = function( obj ) {
          var fn = this
          // 捕获所有 curried参数
          var curried = [].slice.call(arguments, 1)
          var bound = function() {
            return fn.apply(
              (!this||this === (windows || global)) ? obj : this ,
              curried.concat.apply( curried, argument)
            )
          }
          bound.prototype = Object.create( fn.prototype )
          return bound
        }
      }
  对指定函数进行封装,首先检查调用时的this,如果this绑定全局变量或者undefined,就把指定的默认对象obj绑定到this,否则不会修改this,此外,这段代码还支持柯里化
  this词法:
      箭头函数不适用this的四种标准规则,而是根据外层(函数或者全局)作用域决定