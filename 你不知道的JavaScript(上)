1.作用域和闭包
  传统语言编译步骤：分词/词法分析 解析/语法分析 代码生成
  JS保证性能最佳方法：JIT 延迟编译 重编译
  引擎：负责JS编译执行过程
  编译器：语法分析代码生成
  作用域：收集维护所有声明的标识符（变量）组成的一系列查询 并实施一套严格的规则 确定当前执行的代码对这些标识符的访问权限
  var赋值流程：分解成词法单元 词法单位生成一个树结构 判断作用域下是否有相同名称变量 新建变量 生成代码
  引擎查询：LHS、RHS
  LHS：向左查询，试图找到变量容器本身从而进行赋值 赋值操作的目标是谁
  RHS：向右查询，找到变量，非左侧（retrieve his source value）赋值操作的源头
  严格模式禁止LHS找不到的时候创建变量
2.词法作用域
  作用域气泡的结构和相互之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符的位置
  遮蔽效应：会在查找到第一个匹配的标识符的时候结束，所以不同作用域可以定义同名变量
  函数作用域只和声明时的位置有关
  词法作用域只会查找一级标识符，找到变量后对象属性访问规则会分别接管对象内属性的访问
  eval欺骗作用域，包含声明时，会修改所在位置的作用域
  JS定时器第一个参数可以是字符串（不推荐使用）
  new Function（ ）也可以传递字符串语句
  with通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身，没有完全隔离的语法作用域，因此容易造成作用域泄漏
  JS引擎会在编译阶段进行数项性能优化，其中某些优化依赖于能根据代码的词法进行静态分析，并预先确定函数和变量的定义位置，才能快速找到标识符，因此扰乱作用域会使这些优化白做功
3.函数作用域和块作用域
  函数作用域是指属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域也可以使用），能充分利用JS变量可以根据需要改变值类型的动态特性
  函数作用域的好处：隐藏内部实现，规避冲突
  函数作用域的问题：自身函数命名污染作用域，解决：自执行函数
  PS：如果function是声明第一个词是函数声明，否则就是函数表达式
  匿名函数缺点：在栈追踪中不会显示有意义用户名，调试困难、如果没有函数名，需要引用自身时只能用arguments.callee引用、省略了函数名降低了可读性
  自执行函数：因为函数本身被包裹在（）中，所以是一个表达式，第二个（）立即执行这个函数
  let：绑定变量到当前作用域
  垃圾回收：let 可以避免闭包产生的阻拦垃圾回收的问题
  for循环头的let不仅将i绑定到for循环块中，事实上它将其重新绑定在循环的每一个迭代中，确保使用上一个迭代结束时的值进行重新赋值
4.提升
  引擎会在解释JS代码之前首先进行编译，编译的一部分工作就是找到所有的声明，并用合适的作用域关联起来
  只有声明本身会被提前，赋值和其他代码不变，每个作用域都会提升操作。
  函数和变量都会提升，并且函数会被首先提升，然后才是变量，并且应该避免块作用域内声明函数
5.作用域闭包
  当函数可以记住并访问所在词法作用域时，就产生了闭包，即使函数在当前词法作用域外执行
  通过闭包访问引用返回的函数，函数所在的作用域不会被引擎销毁。
  模块模式的必要特点：必须要有外部的封闭函数，该函数至少要被调用一次（每次调用都会创建一个新的模块）、封闭函数必须要返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并可以访问或者修改内部状态
  一个具有函数属性的对象本身并不是真正的模块，从方便观察角度看，一个函数调用所返回的，只有数据属性没有闭包函数的对象并不是真正的模块
  import可以将一个模块中的一个或多个API倒入当前作用域中，并分别绑定在一个变量上
  module会将整个模块的API倒入并绑定在一个变量上
  export会将当前模块的一个标识符导出为公共API
  模块化的特征：为创建内部作用域而了一个包装函数、包装函数的返回值必须至少包括一个对函数内部的引用
6.this
  this提供了一种更优雅的方式来隐式传递一个对象引用，因此可以将API设计得更加简洁并易于复用。
  arguments.callee可以引用当前运行的函数对象（已弃用）
  this是运行时绑定的，上下文取决于函数调用的条件，this声明和函数定义没有任何关系，只取决于函数调用方式，传入参数等信息，this就是记录其中一个属性，会在函数执行中调用
  默认绑定：直接使用不带修饰的函数调用
  隐式绑定：调用时有上下文对象或者被某个对象拥有或包含
  显式绑定：call apply bind 第一个参数如果传入了原始值，那么会被转换成对象形式（new String（））
        function bind(fn,obj){
          return function(){
            return fn.apply(obj,arguments)
          }
        }
    API调用的上下文：api通过传入参数实现回调函数指定this
  new绑定：JS特殊的构造函数只是一些使用new操作符时调用的函数，不属于某个类，也不会实例化一个类，实际上甚至不能说是一种特殊的函数类型，只是被new调用的普通函数。被称为构造函数调用（不存在构造函数 只有构造调用）
  new调用函数的步骤：
    1.创建一个全新的对象
    2.绑定原型给这个对象
    3.绑定this
    4.如果没有返回其他对象，那么new会自动返回这个对象
  优先级：默认绑定<隐式绑定<显式绑定<new
  polyfill处理旧浏览器的兼容问题，比如bind，但是因为不是内置函数无法创建不含.prototype的函数，会有一些副作用

          this.instanceof FNOP&&
          oThis?this:oThis
          // 以及
          FNOP.prototype = this.prototype
          fBound.prototype = new FNOP
  这段代码会判断函数是否被new调用，如果是就会用新创建的this替代已有的this
  使用new的原因：主要目的是预先设置函数的一些参数，这样使用new进行初始化就可以只传入剩余参数
  bind的功能之一就是把第一个参数this外的其他参数都传给下层函数（柯里化的一种）
  判断this
  可以通过优先级来判断函数在某个调用位置应用的是哪条规则,按照下面的顺序进行判断
     1.函数是否在new中调用(new绑定)?如果是的话this绑定的是新创建的对象
     2.函数是否通过apply/call(显式绑定)或者硬绑定调用?如果是的话,this绑定的是指定的对象
     3.函数是否在某个上下文对象中调用(隐式绑定)?如果是的话,this绑定的是那个上下文对象
     4.如果都不是的话,使用默认绑定,如果在严格模式下,就绑定undefined,否则绑定全局对象
  例外:
     如果把null或者undefined传入call,会被忽略,并把this默认绑定(用apply展开数组用...替代)
  更安全的this:
     Object.create(null)创建一个空对象(不会创建prototype)然后作为this传入call/apply/bind
  间接引用
      function foo(){
        console.log(this.a)
      }
      var a = 2
      var o = { a: 3, foo: foo }
      var p = { a: 4 }
      o.foo() // 3
      (p.foo = o.foo)() // 2
  软绑定:
      if(!Function.prototype.softBind){
        Function.prototype.softBind = function( obj ) {
          var fn = this
          // 捕获所有 curried参数
          var curried = [].slice.call(arguments, 1)
          var bound = function() {
            return fn.apply(
              (!this||this === (windows || global)) ? obj : this ,
              curried.concat.apply( curried, argument)
            )
          }
          bound.prototype = Object.create( fn.prototype )
          return bound
        }
      }
  对指定函数进行封装,首先检查调用时的this,如果this绑定全局变量或者undefined,就把指定的默认对象obj绑定到this,否则不会修改this,此外,这段代码还支持柯里化
  this词法:
      箭头函数不适用this的四种标准规则,而是根据外层(函数或者全局)作用域决定
7.对象
  对象定义的两种方式：字面量/构造函数
  唯一的区别：字面量你可以添加多个键值对，构造函数需要逐个添加属性
  null有时候会被当作对象，这是JS的bug 即对null执行typeof会返回object
  JS万物皆对象是错误的
  JS有许多特殊的对象子类型，我们称之为复杂基本类型
  函数是对象的子类型，是JS中的一等公民，本质上和普通对象一样，可以像一个对象一样操作
  数组也是对象的一种类型，具备一些额外的行为，数组比一般的对象要稍微复杂

  内置对象：String，Nubmer，Boolean，Object，Function，Array，Data，RegExp，Error
  可以当作构造函数来使用，，从而可以构造一个对应子类型的新对象

  字符串调用字符串对象方法时引擎会自动把字符串字面量转换为String对象（尽量不要用构造方法）
  null，undefined没有构造形式，Date只有构造形式
  Object，Array，Function，RegExp来说，无论字面量还是构造函数都是对象
  Error很少在代码中显式创建，一般是抛出异常时自动创建

  内容：对象的内容是一些存储在特定命名位置（任意类型）值组成的，我们称之为属性，语言上内容暗指这些值被存储在对象内部，但这只是表现形式，实际在引擎内部，存储方式多种多样，一般不会存在对象内部，而是通过名称引用指针指向真正的存储位置
  .和[]访问对象值的区别：属性访问和键访问，访问同一个位置，主要区别在于.操作符要求属性名满足标识符命名规范，而[]则接受所有UTF8/Unicode字符串作为属性名，比如说Super-Fun！只能通过[]访问（赋值时无论属性名是啥都会转成字符串）
  可计算属性值：可以在声明时通过[a+b计算属性名]
  复制对象老方法：

  新方法：
let obj1=Object.assign（{},obj2）
  （writable之类的特性不会复制）
  属性描述符

  writable 可写
  enumerable 可枚举
  configurable 可配置
    但是可单程把writeable修改为false，同时禁用delete，不可删除对象属性
  Object.praventExtensions(obj)禁止添加属性
  Object.seal()会创建一个密封对象，相当于调用praventExtensions，并把configurable设置为false
  Object.freeze()创建一个冻结对象，相当于对现有对象调用seal并把writable设置为false（引用对象不受影响）
  obj.a实际上实现了[[GET]]操作，类似函数调用执行，对象默认首先查找对象中是否有名称相同的属性，找到就返回，否则就查找原型链，实在找不到返回undefined
  既然可以get那么自然可以put，[[PUT]]被触发会检查以下内容：
    属性是否访问描述符，如果是并存在setter就调用setter
    属性数据描述符中writable是否为false，如果是在非严格模式中静默失败，在严格模式中抛出TypeError异常
    如果都不是，将该值设置为该属性的值
  在语言的未来/高级特性中，有可能改写整个对象（不仅仅是某个属性）
  ES5中使用getter/setter部分改写默认操作，但只能用在单个属性上，无法应用在整个对象上，getter/setter是个隐藏函数，会在获取属性时调用，setter会在设置属性时调用
  给一个属性定义getter/setter时，这个属性会被定义为“访问描述符”，对于访问描述符来说，JS会忽略它们的value和writable特性，取而代之的是set和get（还有configurable和enumerable）特性


  二者都会在对象中创建一个不包含值的属性，这个属性会自动调用一个隐藏函数，返回值会被当成当前属性的返回值

    in操作符会检查原型链
    hasOwnProperty只会检查当前对象
  枚举:enumerable设置为false之后，属性就不会出现在for-in循环中
  在数组上应用for..in 循环有时会产生出人意料的结果，因为这种枚举不仅会包含所有数值索引，还会包含所有可枚举属性。最好只在对象上应用for..in 循环，如果要遍历数组就使用传统的for 循环来遍历数值索引。
  可以判断属性是否可以被枚举的方法:
    obj.propertyIsEnumerable:会检查给定的属性名是否直接存在于对象中（而不是在原型链上）并且满足enumerable:true
    Object.keys:会返回一个数组，包含所有可枚举属性
    Object.getOwnPropertyNames:会返回一个数组，包含所有属性，无论它们是否可枚举
  普通for循环并不是遍历值,而是遍历下标来指向值
  ES5中增加了一些数组的辅助迭代器 包括forEach/every/some,每种辅助迭代器都能接受一个回调函数并把它应用到数组的每个元素上，唯一区别就是它们对于回调函数的返回值处理方式不同
    forEach 忽略返回值
    some 一直运行到true
    every 一直运行到false
  for-of循环首先会向被访问的对象请求一个迭代器对象，然后通过迭代器对象的next()方法来遍历所有返回值，数组有内置的@@iterator，因此for-of能直接应用在数组上
  使用ES6 中的符号Symbol.iterator 来获取对象的@@iterator，引用类似iterator 的特殊属性时要使用符号名，而不是符号包含的值。此外，虽然看起来很像一个对象，但是@@iterator 本身并不是一个迭代器对象，而是一个返回迭代器对象的函数——这点非常精妙并且非常重要
  可以通过Object.defineProperty给对象定义迭代器属性

  for-of循环每次调用myObject迭代器的next()方法时，内部的指针都会向前移动并返回对象列表的下一个值(提醒：需要注意遍历对象属性/值的顺序)

8.类
   类/继承描述了一种代码的组织结构形式，一种在软件中对真实世界问题领域的建模
   面向对象编程强调数据和操作数据本质上是互相关联的，好的设计就是把数据和它的相关行为打包(封装)起来，这被称作数据结构
   多态:父类的通用型万可以被子类用更特殊的行为重写，同时相对多台性允许我们重写行为中引用基础行为
   类理论强烈建议父类和子类使用相同的方法名来表示特定的行为，从而让子类重写父类。在JavaScript 代码中这样做会降低代码的可读性和健壮性。
   JS本身并没有类，类是一种设计模式，JS一直阻止使用类设计模式

  混入：复制共享对象属性和方法
  待学习

  寄生混入：新建一个父类实例然后改写方法
