# 高程笔记
## script
### html解析script
  - html的script标签解析到</script>就会结束
  - 含有src属性的script会忽视内嵌代码
  - script的defer属性可以让资源立即下载延迟执行,html5要求延时脚本会先于DOMContentLoaded执行,但是实际上不一定
  - script的async属性也可以让资源立即下载延迟执行,但是与defer相比不会按顺序执行,一定会在load事件前执行,不确定在DOMContentLoaded前后执行
### 文档模式
  - 文档模式通过文档类型切换实现1.混杂模式 会让ie行为和ie5相同2.严格模式 会让ie的行为更接近标准行为
## noscript标签
  - 用于不支持JS的浏览器
## 基本概念
### 严格模式 
  - 严格模式对JS的执行进行限制
### Number类型
  - 可以通过0开头输出8进制
  - 如果字面值超出范围则专为十进制
  - 严格模式8进制字面量无效
  - 0x开头是16进制
  - 8进制和16进制计算时都会被转为十进制
  - 不要用两个小数相加进行bool判断,有误差
  - Number.MAX_VALUE/MIN_VALUE是JS能表示的最大最小值 1.7e+308和5e-324
  - 超出范围的数字是Infinity,可以用isFinite()判断
  - 可以用isNaN()判断是否是NaN
### String
  - String用于表示0或多个16位Unicode字符组成的字符序列
  - 字符串都是不可变的,字符串一旦创建,其值就不会改变,除非销毁原来字符串重新创建一个
  - 几乎每个值都有toString(),toString可以传递一个参数表转换进制

### Object
  - Object是所有对象的基础

### 操作符
  - 对象的运算会先调用valueOf,从返回的值进行运算

### 布尔操作符
  - 如果有null,NaN或undefined,那么返回他自己

### 乘性操作符
  - 会对非数学进行Number类型转换
### 加性操作符
  - 拼接字符串

### 关系操作符
  - 比较操作返回布尔值

### 语句
  - if,for,while的条件语句会自动把括号内的内容内容转换为Boolean值作判断
  - 使用for..in之前,先检测值是不是null或undefined
  - 使用label语句可以在代码中添加标签以便将来使用,配合break或continue使用,可以实现内部循环break退出外部循环
  - 严格模式禁用with
  - switch进行的是全等操作,case可以对语句进行强制布尔转换
  - 严格模式不能把函数名参数名命名为eval或arguments
  - ES函数参数是用数组表示的,可以通过arguments来访问这个参数数组
  - arguments是类数组对象
  - ES函数参数传递都不是引用传递而是值传递

## 变量、作用域、内存问题
  - 所有函数参数都是按值传递的,对象会被改变是因为传进去的是地址
  - ES规定只要原型有call的对象都应该typeof返回function
  - ie9之前某些对象不是js原生对象,因此某些情况容易导致性能问题
  - 通过赋值null解除引用,等垃圾回收机制下次执行的时候清理掉

## 引用类型

### Object
  - 对象是某个特定引用类型的一个新实例
  - 新对象是new接一个构造函数创建的,构造函数本身是一个函数
  - 用字面量定义对象时实际不会掉用Object构造函数

### Array
  - 用字面量构造数组的时候也不会调用Array构造函数
  - Array.isArray(value)判断是否是数组
  - 输出数组的时候默认会调用数组每一项的toString方法,调用数组toLocalString方法也会调用每个项的toLocalString方法
  - 数组toString方法默认用逗号分隔,可以用join自定义分隔符(用undefined也是逗号,ie7前除外)
  - push可以接受任意数量的参数,添加到数组尾部,返回修改后的数组的长度
  - pop减少数组最后一项’减少长度,返回被移除项
  - shift可以移除队列第一项并把长度-1
  - unshift可以从首项添加一个元素并使长度+1,并返回新数组长度
  - reserve会反转数组
  - sort的默认升序,还会调用每一项的toString方法,可以用回调函数定制排序方式,接收两个参数为比较的两个参数,返回正值正序,负值倒序,0表示相等
  - concat会创建一个当前数组的副本,然后将接收到的参数添加到这个数组末尾(没有参数只是单纯复制)
  - slice接收两个参数代表起始位置和结束位置,并创建一个新数组返回
  - splice能够根据传入蚕食不同进行删除插入替换,并且始终返回一个数组,为被删除的项
  - indexOf,lastIndexOf都接收两个参数,要查找的项和起始位置(可选)然后返回找到的位置,没找到返回-1
  - 迭代
    1. every
    2. filter
    3. forEach
    4. map
    5. some
  - 缩小方法
    1. reduce
    2. reduceRight
  ### Date
  - ES的Date基于早期Java的java.util.Date类构建
  - 使用UTC(国际协调时间)
  - Date.parse接收一个表示日期的字符串参数(各浏览器支持程度不同)返回毫秒数
  - Date.UTC方法构建需要参数不同,也返回毫秒数
  - Date构造函数也会模仿上面两个函数,但是是基于本地时间
  - Date.now()获取当前时间毫秒值
  - Date重写了继承来的toLocalString,toString,ValueOf方法,改成返回时间信息
  
  ### RegExp
  - /pattern/flags
  - flags有三个属性
    1. g表示全局,并非发现第一个字符串就停止
    2. i表示不区分大小写
    3. m表示多行模式
  - 构造函数创建正则两个参数都是字符串
  - 不加g的正则匹配每次匹配都会更新索引
  - 每个RegExp实例都有以下属性
    1. global
    2. ignoreCase
    3. lastIndex
    4. multiline
    5. source
             - 返回正则表达式的字符串模式
  - exec接收一个参数,要应用模式的字符串,然后返回包含第一个匹配项的数组,没有匹配的时候返回null,返回的数组包含两个额外的属性,index和input,表示匹配位置和应用的字符串,不设置g的情况会一直只匹配第一个符合条件的字符串,设置g后每次匹配的都是下一项
  - test接受一个字符串参数,返回布尔值
  - 进行匹配后可以直接调用RegExp的属性调用最后匹配的一些数据
  ```
  let text = 'this has been a short number'
  	let pattern =/(.)hort/g
  	if(pattern.test(text)){
  	    console.log(RegExp.input)           // this has been a short number
  	    console.log(RegExp.leftContext)     // this has been a
  	    console.log(RegExp.rightContext)    // number
  	    console.log(RegExp.lastMatch)       // short
  	    console.log(RegExp.lastParen)       // s
  	    console.log(RegExp.multiline)       // false
  	}
  ```
  
  ### Function
  - 函数实际上是对象,每个函数都是Function类型的实例,而且都与其他引用类型一样具有属性和方法
  - 由于函数是对象,因此函数名实际上也是一个指向函数对象的指针,不会与某个函数绑定
  - Function构造函数最后一个字符串参数是表示函数体(不推荐使用因为会解析两次代码)
  - 解释器会首先读取函数声明,并使其在执行所有代码前可用
  - arguments是一个类数组对象,包含一个callee的属性指向函数本身
  - this引用的是函数的执行环境对象
  - ES5规范了一个函数属性caller,用于获取函数的执行环境
  - 函数包含两个属性length和prototype,length表示函数希望接收的参数个数,prototype是函数保存所有实例方法的地方
  - apply接收数组,call正常接收参数
  - call必须明确传入所有参数

### 基本包装类型
  - 每当读取一个基本类型,后台就会创建一个对应的基本包装类型对象,从而让我们能够直接调用类型的一些方法
  - 基本类型调用方法的过程
    1. 创建一个基本类型实例
    2. 在实例中调用指定的方法
    3. 销毁实例
  - 引用类型的调用方法和基本类型最大的区别就是不会销毁实例直到离开作用域
  - Boolean类型实例重写了valueOf方法,返回true和false,重写了toString方法返回”true”和”false”
  - Number也重写了valueOf和toString方法
  - Number.toString可以转换进制
  - Number.toFixed可以四舍五入小数点
  - Number.toExponential可以转换为指数表达式
  - String类型每个实例都有一个length属性表示字符串字符数量,即使是双子节字符也只算一个字符
  - charAt返回字符串指定位置的字符
  - charCodeAt返回指定位置的字符编码
  - concat可以把一个或多个字符串拼接起来,并返回新字符串
  - slice 接收起始字符位置,结束位置,返回一个新字符串,第二个参数负数表示倒数
  - substring 接收起始字符位置,结束位置,返回一个新字符串,第二个参数负值会被转成0
  - substr 接收起始字符位置,返回字符个数,返回一个新字符串,第二个参数负数表示倒数
  - indexOf和lastIndexOf第二个参数表示从哪一位置开始查找
  - trim创建一个字符串副本,删除前后空格,Chrome还支持非标准的trimLeft和trimRight
  - toLowerCase,toUpperCase转换大小写
  - toLowerLocalCase,toLocalUpperCase针对特定地区实现
  - match本质上与exec相同,只接受一个参数,要么是正则表达式要么是RegExp对象,返回匹配元素的数组
  - search与match参数相同,返回第一个匹配项的索引,找不到返回-1
  - replace第一个参数是RegExp或者字符串,第二个参数是一个字符串或者一个函数,如果第一个参数是字符串,那么只会替换第一个匹配到的字符串,想要替换所有只能用正则修饰符g,如果第二个参数是字符串,还可以使用一些特殊的字符串序列,将正则表达式操作得到的值插入结果字符串(127
  - split可以基于指定分隔符将一个指定分隔符分割为若干个字符串组成的数组,参数可以是正则表达式或数组,第二个参数为指定数组的大小
  - localCompare比较两个字符串在字母表的位置,返回正数,0,负数
  - fromCharCode接收1或多个字符编码,返回字符串
#### 单体内置对象
  - ECMA对内置对象的定义:由ECMA提供实现,不依赖于宿主对象,在ES程序执行之前已经存在,已经被实例化
  - Global不属于其他对象的方法最终都属于它,但是它其实并不存在,所有全局作用域定义的属性和函数,都是Global对象
##### URI编码转换
  - Global的encodeURI和encodeURIComponent可以对URI进行编码,以便发送给浏览器,用特殊的UTF8编码替换所有无效字符,以便浏览器能接受和理解,encodeURL针对整个URI,但不会对本身属于URI的字符进行转换(只会转换空格),encodeURIComponent针对字符中的一段所有特殊字符进行编码
  - decodeURI和decodeURIComponent可以进行解码
  - 这几个方法用于替代escape和unescape
##### eval
  - ES解析器,接收字符串代码执行
  - eval创建的变量不会提神,解析代码的时候,被包含在一个字符串中,只在eval执行的时候创建
  - 严格模式禁止外部访问eval内创建的变量,禁止给eval赋值
##### window对象
  - 浏览器用window对象的一部分代表Global对象
#### Math对象
  - Math对象保存了一些特殊值
  - Math.max()/Math.min()可以求数组最大值和最小值
  - Math.ceil()/Math.floor()/Math.round()可以进行舍入操作
  - random返回一个0到1之间的随机数,不包括0和1,通常用Math.floor(Math.random*可能值的总数+第一个可能的值)来随机选定一个值
  - abs求绝对值

## 面向对象程序设计
  - ES规定”无序属性的集合,其属性可以包含基本值,对象或者函数”
  - ES5规定对象属性的特征,定义特征是为了实现引擎用的,总共有数据属性和访问器属性两种
  - 数据属性:Writable,Emumerable,Configurable,Value
  - 访问器属性不包含数值,包含一对getter和setter方法,读取和写入值的时候调用
  - ES5定义了Object.defineProperties可以一次定义多个属性,这个方法接受两个对象参数,添加要修改属性的对象,修改的属性对象
  - ES5定义了Object.getOwnPropertyDescriptor()可以取得给定属性的描述符,接收两个参数,所在对象和属性名,返回一个包含修饰符的对象
  
#### 工厂模式
  - 工厂模式是软件工程一种广为人知的设计模式
  - 抽象了创建具体对象的过程
  ```
  function createPerson(name, age, job) {
        let o = {}
        o.name = name
        o.age = age
        o.job = job
        o.sayName = function () {
            console.log(this.name)
        }
        return o
    }
    let friend = createPerson('Van', 18, 'actor')
    friend.sayName('Van', 18, 'actor')
  ```
  - JS的工厂模式实现无法解决对象识别的问题
  
#### 构造函数模式
  - ES中构造函数可以创建特定类型的对象
  ```
  function Person(name, age, job) {
        this.name = name
        this.age = age
        this.job = job
        this.sayName = function () {
            console.log(this.name)
        }
    }
    let p1 = new Person('Van', 18, 'actor')
    p1.sayName()
  ```
  - 构造函数模式没有显式地创建对象
  - 将属性和方法直接赋值给了this对象
  - 没有return语句
  - new的四步操作
    1. 创建新对象
    2. 绑定this
    3. 执行构造函数的代码
    4. 返回新对象
  - new出来对象的constructor指向构造函数,但是还是instanceof更靠谱
  - 任何函数通过new调用,就可以作为一个构造函数
  - 构造函数的每个方法都会在实例上创建一遍
  - 构造函数的缺点
    - 每个方法都要重新创建
    - 可以使用全局方法赋值解决这个问题,但是失去了面向对象的意义
  
#### 原型模式
  - prototype是通过调用构造函数而创建的对象实例的原型对象,包含可以由特定类型所有实例共享的属性和方法
  ```
  function Person() {
  }
  Person.prototype.name = 'Van'
  Person.prototype.age = 18
  Person.prototype.job = 'actor'
  Person.prototype.sayName = function () {
  	console.log(this.name)
  }
  let p1 = new Person()
  p1.sayName()
  let p2 = new Person()
  p2.sayName()
  ```
  - 所有原型对象都有一个constructor属性包含一个指向prototype属性所在函数的指针
  - 没有标准的方式访问prototype,但是除了IEOP都支持__proto__属性,存在于构造函数而非实例上
  - isPrototype判断一个原型是否是实例的原型
  - getPrototype获取原型
  - hasOwnPrototype可以检测一个属性是否在实例中
  - in操作符会访问原型上可访问的属性
  - Object.keys可以获取对象上所有可枚举属性的字符串数组
  - instanceof和isPrototypeOf只要原型链上出现就会返回true
  - 原型链上的引用类型属性会有被改动的风险
  
#### 组合使用构造函数和原型模式
  - 构造函数模式用于定义实例属性,原型模式用于定义方法和共享属性  
  ```
  function Person(name, age, job) {
      this.name = name
      this.age = age
      this.job = job
      this.friends = ['Apple', 'Banana']
  }
  Person.prototype = {
      constructor: Person,
      sayName: function () {
          console.log(this.name)
      }
  }
  let p1 = new Person('Van', 18, 'actor')
  let p2 = new Person('2', 24, 'student')
  p1.friends.push('Van')
  console.log(p1.friends)
  console.log(p2.friends)
  console.log(p1.friends === p2.friends)
  console.log(p1.sayName === p2.sayName)
  ```
#### 动态原型模式
  - 通过检查某个应该存在的方法是否有效,来决定是否初始化原型
  ```
  function Person(name, age, job) {
      this.name = name
      this.age = age
      this.job = job
      if(typeof this.sayName !== 'function'){
          Person.prototype.sayName = function () {
              console.log(this.name)
          }
      }
  }
  let friend = new Person('Van',18,'actor')
  friend.sayName()
  ```
  - 还可以使用instanceof来判断类型
#### 寄生构造函数模式
  - 基本思想是创建一个函数,该函数的作用仅仅是封装创建对象的代码,然后再返回新创建的对象
  ```
  function Person(name, age, job) {
      let o = {}
      o.name = name
      o.age = age
      o.job = job
      o.sayName = function () {
          console.log(this.name)
      }
      return o
  }
  let friend = new Person('Van', 18, 'actor')
  friend.sayName()
  ```
  - 跟工厂模式其实一摸一样
  - 返回的对象与构造函数或者构造函数的原型属性没有关系
  - 不建议用这种模式
#### 稳妥构造函数模式
  - 道格拉斯·克罗克福德发明了稳妥对象的概念
  - 指没有公有属性,且方法也不引用this的对象
  - 稳妥对象最适合在一些安全环境中(禁止使用this和new)或者防止数据被其他应用程序改动的时候使用
  - 与寄生构造函数类似,但是有两点不同
    1. 不使用this
    2. 不使用new
  ```
  function Person(name, age, job) {
        let o = {}
        // 定义私有变量和函数
        o.name = name
        o.age = age
        o.job = job
        // 添加方法
        o.sayName = function () {
            console.log(this.name)
        }
        return o
    }
    let friend = Person('Van', 18, 'actor')
    friend.sayName()
  ```
### 继承
#### 原型链
  - ES继承基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法
  - 每个构造函数都有一个原型对象,原型对象都包含一个指向构造函数的指针
  - 实例都包含一个指向原型对象的内部指针
  - 原型对象包含另一个原型的指针
  - 原型继承的实现
  ```
  function Father() {
  	this.property = true
  }
  Father.prototype.getFatherValue = function () {
      return this.property
  }
  function Child() {
      this.childPrototype = false
  }
  Child.prototype = new Father()
  Child.prototype.getChildValue = function () {
  	return this.childPrototype
  }
  let instance = new Child()
  console.log(instance.getFatherValue())
  console.log(instance.getChildValue())
  ```
  - 所有引用类型默认都继承Object
  - 所有函数的默认原型都是Object的实例,都有一个内部指针指向Object.prototype
  - 可以通过instanceof和isPrototypeOf()方法检查原型链中是否出现过相关构造函数和原型
  - 通过原型链实现继承的时候,不能使用字面量创建原型方法,因为这样回重写原型链
  - 原型链的问题
    - 引用类型值的原型所有子类共享
    - 创建子类实例的时候不能向超类构造函数中传递参数(不影响所有对象实例的情况下给超类构造函数传递参数)
#### 借用构造函数
  - 又称伪造对象或者经典继承
  - 构造函数中绑定this,避免公用原型上引用类型属性的尴尬
  ```
  function Father() {
  	this.colors = ['red','blue','green']
  }
  function Child() {
      Father.call(this)
  }
  let instance1 = new Child()
  instance1.colors.push('black')
  console.log(instance1.colors)
  let instance2 = new Child()
  console.log(instance2.colors)
  ```
  - 相对原型链,借用构造函数还有可以给超类构造函数传递参数的的功能
  - 借用构造函数复用效果差,无法判断类型
#### 组合继承
  - 又名伪经典继承,整合借用构造函数和原型链
  - 使用原型链实现对原型属性和方法的继承,通过借用构造函数来实现对实例属性的继承
  - 最常用的继承,但是无论什么情况都会调用两次超类的构造函数(创建子类原型和构造函数内部)
  ```
  function Father(name) {
      this.name = name
      this.colors = ['red', 'blue', 'green']
  }
  Father.prototype.sayName=function(){
      console.log(this.name)
  }
  function Child(name,age) {
      Father.call(this,name)
      this.age = age
  }
  Child.prototype = new Father()
  Child.prototype.sayAge= function(){
      console.log(this.age)
  }
  let instance1 = new Child('Van',18)
  instance1.colors.push('black')
  console.log(instance1.colors)
  instance1.sayName()
  instance1.sayAge()
  let instance2 = new Child('Greg',2)
  console.log(instance2.colors)
  instance2.sayName()
  instance2.sayAge()
  ```
#### 原型式继承
  - 基于原型,通过已有的对象生成新的对象,同时还不用因此创建自定义类型
  ```
  function object(o) {
  	function F() {
      }
      F.prototype = o
  	return new F()
  }
  let person = {
      name:'Van',
  	friends:['David','Tim']
  }
  let anotherPerson = object(person)
  anotherPerson.name = 'Grey'
  anotherPerson.friends.push('Candy')
  ```
  - 要求必须有一个对象可以作为另一个对象的基础,然后函数将其进行修改即可
  - ES5中定义了Object.create来进行原型式继承,第一个参数是新对象的原型对象,第二个对象是属性描述符
  ```
  let person = {
      name:'Van',
  	friends:['David','Tim']
  }
  let anotherPerson = Object.create(person)
  anotherPerson.name = 'Grey'
  anotherPerson.friends.push('Candy')
  console.log(anotherPerson)
  ```
#### 寄生式继承
  - 寄生式继承是创建一个用于封装继承过程的函数,函数内部用某种方式来增强对象,最后返回对象
  ```
  function object(o) {
      function F() {
      }
      F.prototype = o
      return new F()
  }
  function createAnother(original) {
  	let clone = object(original)
  	clone.sayHi = function () {
  		console.log('hi')
      }
      return clone
  }
  let person = {
      name:'Van',
      friends:['David','Tim']
  }
  let anotherPerson = createAnother(person)
  anotherPerson.sayHi()
  ```
  - 寄生继承由于不能做到函数复用而降低效率,跟构造函数模式有点类似
#### 寄生组合式继承
  - 借用构造函数来继承属性,通过原型链的混成形式来继承方法
  - 基本思想:不必为了指定子类的原型而调用超类的构造函数
  - 本质上是使用寄生继承来继承超类原型,然后将结果指定给子类的原型
  ```  
  function object(o) {
      function F() {
      }
      F.prototype = o
      return new F()
  }
  function inheritPrototype(child, father) {
      let prototype = object(father.prototype)
      prototype.constructor = child
      child.prototype = prototype
  }
  function Father(name) {
      this.name = name
      this.colors = ['red', 'blue', 'green']
  }
  Father.prototype.sayName = function () {
      console.log(this.name)
  }
  function Child(name, age) {
      Father.call(this, name)
      this.age = age
  }
  // Child.prototype = new Father()
  inheritPrototype(Child, Father)
  Child.prototype.sayAge = function () {
      console.log(this.age)
  }
  let instance1 = new Child('Van', 18)
  instance1.colors.push('black')
  console.log(instance1.colors)
  instance1.sayName()
  instance1.sayAge()
  let instance2 = new Child('Greg', 2)
  console.log(instance2.colors)
  instance2.sayName()
  instance2.sayAge()
  ```
  
  
## 函数表达式
  - 函数声明会声明提升,函数表达式不会
  - 递归函数赋值给其他参数的时候注意不要销毁原函数指向
  - 可以用arguments.callee表示递归函数自身
  - 严格模式可以用命名函数表达式达成相同的效果
  ```
  var factorial = (function f(nul){
    if(num <= 1){
      return 1
    } else {
      return num * f(num - 1)
    }
  })
  ```
  - 闭包是指有权访问另一个函数作用域的函数
  - 函数第一次被调用的时候,会产生一个执行环境以及对应的作用域链,并把作用域链赋值给一个特殊的内部属性[[Scope]],然后用this、arguments和其他命名参数的值来初始化函数的活动对象
  - 后台每个执行环境都有一个表示变量的对象(变量对象)全局环境的变量对象始终存在,局部环境尽在函数执行过程中存在
  - 创建闭包函数时,会首先创建一个预先包含全局变量对象的作用域链包存在[[Scope]]中
  - 调用闭包函数时,会为函数创建一个执行环境,然后复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链,,然后又有一个活动对象(作为变量对象使用)被创建到执行环境链前端
  - 调用闭包函数,执行环境会销毁,活动对象依旧在内存中
  - IE9前JScript对象和COM对象使用不同的垃圾收集机制,因此闭包在IE中会导致一些特殊问题,比如说闭包作用域链保存着一个HTML元素,该元素就无法销毁,需要手动销毁
## BOM
### window对象
  - window对象即是访问BOM的接口,也是全局作用域Global对象
  - IE9以下浏览器window保存的全局属性默认设置[[Configurable]]为false,因此不可以用delete删除
  - 如果页面包含frame,那么每个frame都有自己的window对象,并保存在frame集合中,可以通过数值索引(从上往下,从左往右)访问或者frame名称来访问相应的window对象,每个window对象都有一个name包含frame的名称
  - top对象始终指向最高层的框架,浏览器窗口,而window对象指向最高层框架的特定实例,子框架的top指向子框架本身
  - top对象和parent对象可以通过window对象访问
  - 除非是通过window.open()打开,否则window.name不会包含任何值
  - screenLeft和screenTop可以获得窗口对于屏幕的位置,Firefox则支持screenX和screenY(Safari和Chrome也支持)
  - FireFox和Safari的screenY或screenTop是相对浏览器顶端而非页面顶端(包含工具栏地址栏的高度)Opera在frame使用top.screenX会返回想对屏幕边界的距离
  - moveTo和moveBy可以移动浏览器窗口(浏览器可能禁用)
  - outerWidth和outerHeight在IE9+,Safari和FireFox返回浏览器窗口尺寸(无论是否是frame)Opera中返回页面视图容器的大小
  - innerWidth和innerHeight返回表示该容器中页面视图大小,减去边框宽度
  - Chrome中outerWidth、outerHeight、innerWidth和innerHeight返回相同的值,都是视口的大小而非浏览器的大小
  - IE8之前没有提供提供访问浏览器窗口大小的接口,但是通过DOM提供了页面可见区域的相关信息
  - 大部分浏览器中document.documentElement.clientWidth和document.documentElement.clientHeight保存了页面视口信息,IE6中这些属性必须标准模式才有用,混杂模式必须通过document.body.clientWidth获取,混杂模式的Chrome两者获取的都是视口的大小
  - 使用resizeTo()和resizeBy()可以修改浏览器窗口大小,接收参数为宽度和高度(浏览器可能禁用)
  - window.open()既可以打开一个特定的URL也可以打开一个新的浏览器窗口,接收四个参数,加载的URL、窗口目标(当前页面a标签的target或_self等特殊窗口名)、一个特性字符(逗号分隔字符串用于决定新页面特性,不打开新窗口的时候会被忽略)、新页面是否取代浏览器当前页面的历史值
  - window.open()返回一个新窗口引用,可以对其进行window对象的大部分操作,甚至可以通过close方法关闭,但是只针对window.open打开的窗口有用
  - 新创建的window对象有个opener属性,保存着打开它的窗口对象,这个对象只在弹出窗口的最外层window对象有用,指向调用open方法的对象,有些浏览器(IE8和Chrome)会在独立的进程里运行每个标签页,如果打开的页面需要彼此通信,就不能运行在独立的进程中,如果新创建的标签页的opener设置为null就代表在新的进程中
  - 浏览器大多都限制弹窗,限制大小或者限制仅能用户操作进行弹窗
  - 如果是浏览器禁止弹窗window.open返回的是null
  - alert、confirm、prompt会终止页面的代码运行,返回值是输入的内容
  - Chrome对弹窗进行了限制,如果页面将要打开超过一个弹窗,那么用户可以选择屏蔽接下来的弹窗,直到刷新页面
  - window.print显示打印对话框,window.find显示查找对话框
  - location提供了当前窗口加载文档有关信息,还提供了一些导航功能
  - location对象即是window的属性也是document的属性,并且引用的是同一个对象
  - local对象的属性
    - hash 返回URL中hash(#后的字符),如果不包含散列,返回空字符串
      - '#contents'
    - host 返回服务器名称和端口号(如果有)
      - 'www.baidu.com:80'
    - hostname 返回不带端口号的服务器名
      - 'www.baidu.com'
    - href 返回当前加载页面的完整URL,而location对象的toString方法也返回这个值
      - 'https://www.baidu.com'
    - pathname 返回URL中的目录或文件名
      - '/src/'
    - port 端口号
      - '80'
    - protocol 使用的协议
      - 'https:'
    - search URL查询字符串,问好开头
      - '?q=javascript'
  - location.search查询字符串先去掉开头的问号,先拆&再拆=
  - location.assign可以立即打开新页面并生成历史记录
    - location.herf和window.location也会调用location.assign
    - 修改location对象的各个属性也能使URL重新加载,并生成新的历史记录
    - 如果要禁用历史记录后退可以使用location.replace
  - window.reload不传递参数的时候会用最有效的方式刷新页面,优先使用缓存,传递true的时候强制忽略缓存
  - navigator.plugins可以获取非IE浏览器所有插件数组,IE需要使用专有的ActiveXObject,尝试创建一个特定插件实例,同时必须获取插件的COM标识符
  - Firefox2为navigator对象新增了navigator.registerContentHeader和navigator.registerProtocolHeader方法(HTML5定义的)
    - 可用于让一个站点指明它可以处理特定类型的消息,随着RSS阅读器和在线电子邮件的兴起,注册处理程序就为像使用桌面应用程一样默认使用这些在线应用程序提供了一种方式(213页)
  - screen对象对于不同浏览器有着不同的属性,availHeight、availWidth、colorDepth、height、width的兼容性较好
  - history对象保存着用户的上网记录,但是开发人员无法获得用户浏览过的URL
  - histpry对象是window对象的属性
  - history.go接受一个整数或者字符串,表示跳转页面栈的数量或历史记录中包含该字符串的页面(可能后退或者前进也可能什么都不做)也可以用forward和back代替go方法
  - history有一个length属性保存着历史记录的数量,让其等于0可以清空历史记录
### 客户端检测
  - IE5前不支持document.getElementById,只能用document.all实现
  - 能力检测指检测浏览器是否支持某个功能,不支持就调用备选方案(优先检测常用的)
  - 不要用是否包含某个属性或者方法来判断兼容性,还需要检测类型
  - 检测几个特性并不能确定浏览器,需要使用不同浏览器的特性前记住一次性判断所有相关特性
