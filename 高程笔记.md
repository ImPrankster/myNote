# 高程笔记
## script
### html解析script
  - html的script标签解析到</script>就会结束
  - 含有src属性的script会忽视内嵌代码
  - script的defer属性可以让资源立即下载延迟执行,html5要求延时脚本会先于DOMContentLoaded执行,但是实际上不一定
  - script的async属性也可以让资源立即下载延迟执行,但是与defer相比不会按顺序执行,一定会在load事件前执行,不确定在DOMContentLoaded前后执行
### 文档模式
  - 文档模式通过文档类型切换实现1.混杂模式 会让ie行为和ie5相同2.严格模式 会让ie的行为更接近标准行为
## noscript标签
  - 用于不支持JS的浏览器
## 基本概念
### 严格模式 
  - 严格模式对JS的执行进行限制
### Number类型
  - 可以通过0开头输出8进制
  - 如果字面值超出范围则专为十进制
  - 严格模式8进制字面量无效
  - 0x开头是16进制
  - 8进制和16进制计算时都会被转为十进制
  - 不要用两个小数相加进行bool判断,有误差
  - Number.MAX_VALUE/MIN_VALUE是JS能表示的最大最小值 1.7e+308和5e-324
  - 超出范围的数字是Infinity,可以用isFinite()判断
  - 可以用isNaN()判断是否是NaN
### String
  - String用于表示0或多个16位Unicode字符组成的字符序列
  - 字符串都是不可变的,字符串一旦创建,其值就不会改变,除非销毁原来字符串重新创建一个
  - 几乎每个值都有toString(),toString可以传递一个参数表转换进制

### Object
  - Object是所有对象的基础

### 操作符
  - 对象的运算会先调用valueOf,从返回的值进行运算

### 布尔操作符
  - 如果有null,NaN或undefined,那么返回他自己

### 乘性操作符
  - 会对非数学进行Number类型转换
### 加性操作符
  - 拼接字符串

### 关系操作符
  - 比较操作返回布尔值

### 语句
  - if,for,while的条件语句会自动把括号内的内容内容转换为Boolean值作判断
  - 使用for..in之前,先检测值是不是null或undefined
  - 使用label语句可以在代码中添加标签以便将来使用,配合break或continue使用,可以实现内部循环break退出外部循环
  - 严格模式禁用with
  - switch进行的是全等操作,case可以对语句进行强制布尔转换
  - 严格模式不能把函数名参数名命名为eval或arguments
  - ES函数参数是用数组表示的,可以通过arguments来访问这个参数数组
  - arguments是类数组对象
  - ES函数参数传递都不是引用传递而是值传递

## 变量、作用域、内存问题
  - 所有函数参数都是按值传递的,对象会被改变是因为传进去的是地址
  - ES规定只要原型有call的对象都应该typeof返回function
  - ie9之前某些对象不是js原生对象,因此某些情况容易导致性能问题
  - 通过赋值null解除引用,等垃圾回收机制下次执行的时候清理掉

## 引用类型

### Object
  - 对象是某个特定引用类型的一个新实例
  - 新对象是new接一个构造函数创建的,构造函数本身是一个函数
  - 用字面量定义对象时实际不会掉用Object构造函数

### Array
  - 用字面量构造数组的时候也不会调用Array构造函数
  - Array.isArray(value)判断是否是数组
  - 输出数组的时候默认会调用数组每一项的toString方法,调用数组toLocalString方法也会调用每个项的toLocalString方法
  - 数组toString方法默认用逗号分隔,可以用join自定义分隔符(用undefined也是逗号,ie7前除外)
  - push可以接受任意数量的参数,添加到数组尾部,返回修改后的数组的长度
  - pop减少数组最后一项’减少长度,返回被移除项
  - shift可以移除队列第一项并把长度-1
  - unshift可以从首项添加一个元素并使长度+1,并返回新数组长度
  - reserve会反转数组
  - sort的默认升序,还会调用每一项的toString方法,可以用回调函数定制排序方式,接收两个参数为比较的两个参数,返回正值正序,负值倒序,0表示相等
  - concat会创建一个当前数组的副本,然后将接收到的参数添加到这个数组末尾(没有参数只是单纯复制)
  - slice接收两个参数代表起始位置和结束位置,并创建一个新数组返回
  - splice能够根据传入蚕食不同进行删除插入替换,并且始终返回一个数组,为被删除的项
  - indexOf,lastIndexOf都接收两个参数,要查找的项和起始位置(可选)然后返回找到的位置,没找到返回-1
  - 迭代
    1. every
    2. filter
    3. forEach
    4. map
    5. some
  - 缩小方法
    1. reduce
    2. reduceRight
  ### Date
  - ES的Date基于早期Java的java.util.Date类构建
  - 使用UTC(国际协调时间)
  - Date.parse接收一个表示日期的字符串参数(各浏览器支持程度不同)返回毫秒数
  - Date.UTC方法构建需要参数不同,也返回毫秒数
  - Date构造函数也会模仿上面两个函数,但是是基于本地时间
  - Date.now()获取当前时间毫秒值
  - Date重写了继承来的toLocalString,toString,ValueOf方法,改成返回时间信息
  
  ### RegExp
  - /pattern/flags
  - flags有三个属性
    1. g表示全局,并非发现第一个字符串就停止
    2. i表示不区分大小写
    3. m表示多行模式
  - 构造函数创建正则两个参数都是字符串
  - 不加g的正则匹配每次匹配都会更新索引
  - 每个RegExp实例都有以下属性
    1. global
    2. ignoreCase
    3. lastIndex
    4. multiline
    5. source
             - 返回正则表达式的字符串模式
  - exec接收一个参数,要应用模式的字符串,然后返回包含第一个匹配项的数组,没有匹配的时候返回null,返回的数组包含两个额外的属性,index和input,表示匹配位置和应用的字符串,不设置g的情况会一直只匹配第一个符合条件的字符串,设置g后每次匹配的都是下一项
  - test接受一个字符串参数,返回布尔值
  - 进行匹配后可以直接调用RegExp的属性调用最后匹配的一些数据
  ```
  let text = 'this has been a short number'
  	let pattern =/(.)hort/g
  	if(pattern.test(text)){
  	    console.log(RegExp.input)           // this has been a short number
  	    console.log(RegExp.leftContext)     // this has been a
  	    console.log(RegExp.rightContext)    // number
  	    console.log(RegExp.lastMatch)       // short
  	    console.log(RegExp.lastParen)       // s
  	    console.log(RegExp.multiline)       // false
  	}
  ```
  
  ### Function
  - 函数实际上是对象,每个函数都是Function类型的实例,而且都与其他引用类型一样具有属性和方法
  - 由于函数是对象,因此函数名实际上也是一个指向函数对象的指针,不会与某个函数绑定
  - Function构造函数最后一个字符串参数是表示函数体(不推荐使用因为会解析两次代码)
  - 解释器会首先读取函数声明,并使其在执行所有代码前可用
  - arguments是一个类数组对象,包含一个callee的属性指向函数本身
  - this引用的是函数的执行环境对象
  - ES5规范了一个函数属性caller,用于获取函数的执行环境
  - 函数包含两个属性length和prototype,length表示函数希望接收的参数个数,prototype是函数保存所有实例方法的地方
  - apply接收数组,call正常接收参数
  - call必须明确传入所有参数

### 基本包装类型
  - 每当读取一个基本类型,后台就会创建一个对应的基本包装类型对象,从而让我们能够直接调用类型的一些方法
  - 基本类型调用方法的过程
    1. 创建一个基本类型实例
    2. 在实例中调用指定的方法
    3. 销毁实例
  - 引用类型的调用方法和基本类型最大的区别就是不会销毁实例直到离开作用域
  - Boolean类型实例重写了valueOf方法,返回true和false,重写了toString方法返回”true”和”false”
  - Number也重写了valueOf和toString方法
  - Number.toString可以转换进制
  - Number.toFixed可以四舍五入小数点
  - Number.toExponential可以转换为指数表达式
  - String类型每个实例都有一个length属性表示字符串字符数量,即使是双子节字符也只算一个字符
  - charAt返回字符串指定位置的字符
  - charCodeAt返回指定位置的字符编码
  - concat可以把一个或多个字符串拼接起来,并返回新字符串
  - slice 接收起始字符位置,结束位置,返回一个新字符串,第二个参数负数表示倒数
  - substring 接收起始字符位置,结束位置,返回一个新字符串,第二个参数负值会被转成0
  - substr 接收起始字符位置,返回字符个数,返回一个新字符串,第二个参数负数表示倒数
  - indexOf和lastIndexOf第二个参数表示从哪一位置开始查找
  - trim创建一个字符串副本,删除前后空格,Chrome还支持非标准的trimLeft和trimRight
  - toLowerCase,toUpperCase转换大小写
  - toLowerLocalCase,toLocalUpperCase针对特定地区实现
  - match本质上与exec相同,只接受一个参数,要么是正则表达式要么是RegExp对象,返回匹配元素的数组
  - search与match参数相同,返回第一个匹配项的索引,找不到返回-1
  - replace第一个参数是RegExp或者字符串,第二个参数是一个字符串或者一个函数,如果第一个参数是字符串,那么只会替换第一个匹配到的字符串,想要替换所有只能用正则修饰符g,如果第二个参数是字符串,还可以使用一些特殊的字符串序列,将正则表达式操作得到的值插入结果字符串(127
  - split可以基于指定分隔符将一个指定分隔符分割为若干个字符串组成的数组,参数可以是正则表达式或数组,第二个参数为指定数组的大小
  - localCompare比较两个字符串在字母表的位置,返回正数,0,负数
  - fromCharCode接收1或多个字符编码,返回字符串
#### 单体内置对象
  - ECMA对内置对象的定义:由ECMA提供实现,不依赖于宿主对象,在ES程序执行之前已经存在,已经被实例化
  - Global不属于其他对象的方法最终都属于它,但是它其实并不存在,所有全局作用域定义的属性和函数,都是Global对象
##### URI编码转换
  - Global的encodeURI和encodeURIComponent可以对URI进行编码,以便发送给浏览器,用特殊的UTF8编码替换所有无效字符,以便浏览器能接受和理解,encodeURL针对整个URI,但不会对本身属于URI的字符进行转换(只会转换空格),encodeURIComponent针对字符中的一段所有特殊字符进行编码
  - decodeURI和decodeURIComponent可以进行解码
  - 这几个方法用于替代escape和unescape
##### eval
  - ES解析器,接收字符串代码执行
  - eval创建的变量不会提神,解析代码的时候,被包含在一个字符串中,只在eval执行的时候创建
  - 严格模式禁止外部访问eval内创建的变量,禁止给eval赋值
##### window对象
  - 浏览器用window对象的一部分代表Global对象
#### Math对象
  - Math对象保存了一些特殊值
  - Math.max()/Math.min()可以求数组最大值和最小值
  - Math.ceil()/Math.floor()/Math.round()可以进行舍入操作
  - random返回一个0到1之间的随机数,不包括0和1,通常用Math.floor(Math.random*可能值的总数+第一个可能的值)来随机选定一个值
  - abs求绝对值

## 面向对象程序设计
  - ES规定”无序属性的集合,其属性可以包含基本值,对象或者函数”
  - ES5规定对象属性的特征,定义特征是为了实现引擎用的,总共有数据属性和访问器属性两种
  - 数据属性:Writable,Emumerable,Configurable,Value
  - 访问器属性不包含数值,包含一对getter和setter方法,读取和写入值的时候调用
  - ES5定义了Object.defineProperties可以一次定义多个属性,这个方法接受两个对象参数,添加要修改属性的对象,修改的属性对象
  - ES5定义了Object.getOwnPropertyDescriptor()可以取得给定属性的描述符,接收两个参数,所在对象和属性名,返回一个包含修饰符的对象
  - new的四步操作:创建新对象,绑定this,执行构造函数的代码,返回新对象
  - new出来对象的constructor指向构造函数,但是还是instanceof更靠谱
  - 任何函数通过new调用,就可以作为一个构造函数
  - 构造函数的每个方法都会在实例上创建一遍
### 原型模式
  - prototype是通过调用构造函数而创建的对象实例的原型对象,包含可以由特定类型所有实例共享的属性和方法
  - 所有原型对象都有一个constructor属性包含一个指向prototype属性所在函数的指针
  - 没有标准的方式访问prototype,但是除了IEOP都支持__proto__属性,存在于构造函数而非实例上
  - isPrototype判断一个原型是否是实例的原型
  - getPrototype获取原型
  - hasOwnPrototype可以检测一个属性是否在实例中
  - in操作符会访问原型上可访问的属性
  - Object.keys可以获取对象上所有可枚举属性的字符串数组
  - instanceof和isPrototypeOf只要原型链上出现就会返回true
  - 原型链上的引用类型属性会有被改动的风险
  - 借用构造函数:构造函数中绑定this,避免公用原型上引用类型属性的尴尬(抽空再看)
===================
## 函数表达式
  - 函数声明会声明提升,函数表达式不会
  - 递归函数赋值给其他参数的时候注意不要销毁原函数指向
  - 可以用arguments.callee表示递归函数自身
  - 严格模式可以用命名函数表达式达成相同的效果
  ```
  var factorial = (function f(nul){
    if(num <= 1){
      return 1
    } else {
      return num * f(num - 1)
    }
  })
  ```
  - 闭包是指有权访问另一个函数作用域的函数
  - 函数第一次被调用的时候,会产生一个执行环境以及对应的作用域链,并把作用域链赋值给一个特殊的内部属性[[Scope]],然后用this、arguments和其他命名参数的值来初始化函数的活动对象
  - 后台每个执行环境都有一个表示变量的对象(变量对象)全局环境的变量对象始终存在,局部环境尽在函数执行过程中存在
  - 创建闭包函数时,会首先创建一个预先包含全局变量对象的作用域链包存在[[Scope]]中
  - 调用闭包函数时,会为函数创建一个执行环境,然后复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链,,然后又有一个活动对象(作为变量对象使用)被创建到执行环境链前端
  - 调用闭包函数,执行环境会销毁,活动对象依旧在内存中
  - IE9前JScript对象和COM对象使用不同的垃圾收集机制,因此闭包在IE中会导致一些特殊问题,比如说闭包作用域链保存着一个HTML元素,该元素就无法销毁,需要手动销毁
