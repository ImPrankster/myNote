# 高程笔记
## script
### html解析script
  - html的script标签解析到</script>就会结束
  - 含有src属性的script会忽视内嵌代码
  - script的defer属性可以让资源立即下载延迟执行,html5要求延时脚本会先于DOMContentLoaded执行,但是实际上不一定
  - script的async属性也可以让资源立即下载延迟执行,但是与defer相比不会按顺序执行,一定会在load事件前执行,不确定在DOMContentLoaded前后执行
### 文档模式
  - 文档模式通过文档类型切换实现1.混杂模式 会让ie行为和ie5相同2.严格模式 会让ie的行为更接近标准行为
## noscript标签
  - 用于不支持JS的浏览器
## 基本概念
### 严格模式 
  - 严格模式对JS的执行进行限制
### Number类型
  - 可以通过0开头输出8进制
  - 如果字面值超出范围则专为十进制
  - 严格模式8进制字面量无效
  - 0x开头是16进制
  - 8进制和16进制计算时都会被转为十进制
  - 不要用两个小数相加进行bool判断,有误差
  - Number.MAX_VALUE/MIN_VALUE是JS能表示的最大最小值 1.7e+308和5e-324
  - 超出范围的数字是Infinity,可以用isFinite()判断
  - 可以用isNaN()判断是否是NaN
### String
  - String用于表示0或多个16位Unicode字符组成的字符序列
  - 字符串都是不可变的,字符串一旦创建,其值就不会改变,除非销毁原来字符串重新创建一个
  - 几乎每个值都有toString(),toString可以传递一个参数表转换进制

### Object
  - Object是所有对象的基础

### 操作符
  - 对象的运算会先调用valueOf,从返回的值进行运算

### 布尔操作符
  - 如果有null,NaN或undefined,那么返回他自己

### 乘性操作符
  - 会对非数学进行Number类型转换
### 加性操作符
  - 拼接字符串

### 关系操作符
  - 比较操作返回布尔值

### 语句
  - if,for,while的条件语句会自动把括号内的内容内容转换为Boolean值作判断
  - 使用for..in之前,先检测值是不是null或undefined
  - 使用label语句可以在代码中添加标签以便将来使用,配合break或continue使用,可以实现内部循环break退出外部循环
  - 严格模式禁用with
  - switch进行的是全等操作,case可以对语句进行强制布尔转换
  - 严格模式不能把函数名参数名命名为eval或arguments
  - ES函数参数是用数组表示的,可以通过arguments来访问这个参数数组
  - arguments是类数组对象
  - ES函数参数传递都不是引用传递而是值传递

## 变量、作用域、内存问题
  - 所有函数参数都是按值传递的,对象会被改变是因为传进去的是地址
  - ES规定只要原型有call的对象都应该typeof返回function
  - ie9之前某些对象不是js原生对象,因此某些情况容易导致性能问题
  - 通过赋值null解除引用,等垃圾回收机制下次执行的时候清理掉

## 引用类型

### Object
  - 对象是某个特定引用类型的一个新实例
  - 新对象是new接一个构造函数创建的,构造函数本身是一个函数
  - 用字面量定义对象时实际不会掉用Object构造函数

### Array
  - 用字面量构造数组的时候也不会调用Array构造函数
  - Array.isArray(value)判断是否是数组
  - 输出数组的时候默认会调用数组每一项的toString方法,调用数组toLocalString方法也会调用每个项的toLocalString方法
  - 数组toString方法默认用逗号分隔,可以用join自定义分隔符(用undefined也是逗号,ie7前除外)
  - push可以接受任意数量的参数,添加到数组尾部,返回修改后的数组的长度
  - pop减少数组最后一项’减少长度,返回被移除项
  - shift可以移除队列第一项并把长度-1
  - unshift可以从首项添加一个元素并使长度+1,并返回新数组长度
  - reserve会反转数组
  - sort的默认升序,还会调用每一项的toString方法,可以用回调函数定制排序方式,接收两个参数为比较的两个参数,返回正值正序,负值倒序,0表示相等
  - concat会创建一个当前数组的副本,然后将接收到的参数添加到这个数组末尾(没有参数只是单纯复制)
  - slice接收两个参数代表起始位置和结束位置,并创建一个新数组返回
  - splice能够根据传入蚕食不同进行删除插入替换,并且始终返回一个数组,为被删除的项
  - indexOf,lastIndexOf都接收两个参数,要查找的项和起始位置(可选)然后返回找到的位置,没找到返回-1
  - 迭代
    1. every
    2. filter
    3. forEach
    4. map
    5. some
  - 缩小方法
    1. reduce
    2. reduceRight
  ### Date
  - ES的Date基于早期Java的java.util.Date类构建
  - 使用UTC(国际协调时间)
  - Date.parse接收一个表示日期的字符串参数(各浏览器支持程度不同)返回毫秒数
  - Date.UTC方法构建需要参数不同,也返回毫秒数
  - Date构造函数也会模仿上面两个函数,但是是基于本地时间
  - Date.now()获取当前时间毫秒值
  - Date重写了继承来的toLocalString,toString,ValueOf方法,改成返回时间信息
  
  ### RegExp
  - /pattern/flags
  - flags有三个属性
    1. g表示全局,并非发现第一个字符串就停止
    2. i表示不区分大小写
    3. m表示多行模式
  - 构造函数创建正则两个参数都是字符串
  - 不加g的正则匹配每次匹配都会更新索引
  - 每个RegExp实例都有以下属性
    1. global
    2. ignoreCase
    3. lastIndex
    4. multiline
    5. source
             - 返回正则表达式的字符串模式
  - exec接收一个参数,要应用模式的字符串,然后返回包含第一个匹配项的数组,没有匹配的时候返回null,返回的数组包含两个额外的属性,index和input,表示匹配位置和应用的字符串,不设置g的情况会一直只匹配第一个符合条件的字符串,设置g后每次匹配的都是下一项
  - test接受一个字符串参数,返回布尔值
  - 进行匹配后可以直接调用RegExp的属性调用最后匹配的一些数据
  ```
  let text = 'this has been a short number'
  	let pattern =/(.)hort/g
  	if(pattern.test(text)){
  	    console.log(RegExp.input)           // this has been a short number
  	    console.log(RegExp.leftContext)     // this has been a
  	    console.log(RegExp.rightContext)    // number
  	    console.log(RegExp.lastMatch)       // short
  	    console.log(RegExp.lastParen)       // s
  	    console.log(RegExp.multiline)       // false
  	}
  ```
  
  ### Function
  - 函数实际上是对象,每个函数都是Function类型的实例,而且都与其他引用类型一样具有属性和方法
  - 由于函数是对象,因此函数名实际上也是一个指向函数对象的指针,不会与某个函数绑定
  - Function构造函数最后一个字符串参数是表示函数体(不推荐使用因为会解析两次代码)
  - 解释器会首先读取函数声明,并使其在执行所有代码前可用
  - arguments是一个类数组对象,包含一个callee的属性指向函数本身
  - this引用的是函数的执行环境对象
  - ES5规范了一个函数属性caller,用于获取函数的执行环境
  - 函数包含两个属性length和prototype,length表示函数希望接收的参数个数,prototype是函数保存所有实例方法的地方
  - apply接收数组,call正常接收参数
  - call必须明确传入所有参数

### 基本包装类型
  - 每当读取一个基本类型,后台就会创建一个对应的基本包装类型对象,从而让我们能够直接调用类型的一些方法
  - 基本类型调用方法的过程
    1. 创建一个基本类型实例
    2. 在实例中调用指定的方法
    3. 销毁实例
  - 引用类型的调用方法和基本类型最大的区别就是不会销毁实例直到离开作用域
  - Boolean类型实例重写了valueOf方法,返回true和false,重写了toString方法返回”true”和”false”
  - Number也重写了valueOf和toString方法
  - Number.toString可以转换进制
  - Number.toFixed可以四舍五入小数点
  - Number.toExponential可以转换为指数表达式
  - String类型每个实例都有一个length属性表示字符串字符数量,即使是双子节字符也只算一个字符
  - charAt返回字符串指定位置的字符
  - charCodeAt返回指定位置的字符编码
  - concat可以把一个或多个字符串拼接起来,并返回新字符串
  - slice 接收起始字符位置,结束位置,返回一个新字符串,第二个参数负数表示倒数
  - substring 接收起始字符位置,结束位置,返回一个新字符串,第二个参数负值会被转成0
  - substr 接收起始字符位置,返回字符个数,返回一个新字符串,第二个参数负数表示倒数
  - indexOf和lastIndexOf第二个参数表示从哪一位置开始查找
  - trim创建一个字符串副本,删除前后空格,Chrome还支持非标准的trimLeft和trimRight
  - toLowerCase,toUpperCase转换大小写
  - toLowerLocalCase,toLocalUpperCase针对特定地区实现
  - match本质上与exec相同,只接受一个参数,要么是正则表达式要么是RegExp对象,返回匹配元素的数组
  - search与match参数相同,返回第一个匹配项的索引,找不到返回-1
  - replace第一个参数是RegExp或者字符串,第二个参数是一个字符串或者一个函数,如果第一个参数是字符串,那么只会替换第一个匹配到的字符串,想要替换所有只能用正则修饰符g,如果第二个参数是字符串,还可以使用一些特殊的字符串序列,将正则表达式操作得到的值插入结果字符串(127
  - split可以基于指定分隔符将一个指定分隔符分割为若干个字符串组成的数组,参数可以是正则表达式或数组,第二个参数为指定数组的大小
  - localCompare比较两个字符串在字母表的位置,返回正数,0,负数
  - fromCharCode接收1或多个字符编码,返回字符串
#### 单体内置对象
  - ECMA对内置对象的定义:由ECMA提供实现,不依赖于宿主对象,在ES程序执行之前已经存在,已经被实例化
  - Global不属于其他对象的方法最终都属于它,但是它其实并不存在,所有全局作用域定义的属性和函数,都是Global对象
##### URI编码转换
  - Global的encodeURI和encodeURIComponent可以对URI进行编码,以便发送给浏览器,用特殊的UTF8编码替换所有无效字符,以便浏览器能接受和理解,encodeURL针对整个URI,但不会对本身属于URI的字符进行转换(只会转换空格),encodeURIComponent针对字符中的一段所有特殊字符进行编码
  - decodeURI和decodeURIComponent可以进行解码
  - 这几个方法用于替代escape和unescape
##### eval
  - ES解析器,接收字符串代码执行
  - eval创建的变量不会提神,解析代码的时候,被包含在一个字符串中,只在eval执行的时候创建
  - 严格模式禁止外部访问eval内创建的变量,禁止给eval赋值
##### window对象
  - 浏览器用window对象的一部分代表Global对象
#### Math对象
  - Math对象保存了一些特殊值
  - Math.max()/Math.min()可以求数组最大值和最小值
  - Math.ceil()/Math.floor()/Math.round()可以进行舍入操作
  - random返回一个0到1之间的随机数,不包括0和1,通常用Math.floor(Math.random*可能值的总数+第一个可能的值)来随机选定一个值
  - abs求绝对值

## 面向对象程序设计
  - ES规定”无序属性的集合,其属性可以包含基本值,对象或者函数”
  - ES5规定对象属性的特征,定义特征是为了实现引擎用的,总共有数据属性和访问器属性两种
  - 数据属性:Writable,Emumerable,Configurable,Value
  - 访问器属性不包含数值,包含一对getter和setter方法,读取和写入值的时候调用
  - ES5定义了Object.defineProperties可以一次定义多个属性,这个方法接受两个对象参数,添加要修改属性的对象,修改的属性对象
  - ES5定义了Object.getOwnPropertyDescriptor()可以取得给定属性的描述符,接收两个参数,所在对象和属性名,返回一个包含修饰符的对象
  
#### 工厂模式
  - 工厂模式是软件工程一种广为人知的设计模式
  - 抽象了创建具体对象的过程
  ```
  function createPerson(name, age, job) {
        let o = {}
        o.name = name
        o.age = age
        o.job = job
        o.sayName = function () {
            console.log(this.name)
        }
        return o
    }
    let friend = createPerson('Van', 18, 'actor')
    friend.sayName('Van', 18, 'actor')
  ```
  - JS的工厂模式实现无法解决对象识别的问题
  
#### 构造函数模式
  - ES中构造函数可以创建特定类型的对象
  ```
  function Person(name, age, job) {
        this.name = name
        this.age = age
        this.job = job
        this.sayName = function () {
            console.log(this.name)
        }
    }
    let p1 = new Person('Van', 18, 'actor')
    p1.sayName()
  ```
  - 构造函数模式没有显式地创建对象
  - 将属性和方法直接赋值给了this对象
  - 没有return语句
  - new的四步操作
    1. 创建新对象
    2. 绑定this
    3. 执行构造函数的代码
    4. 返回新对象
  - new出来对象的constructor指向构造函数,但是还是instanceof更靠谱
  - 任何函数通过new调用,就可以作为一个构造函数
  - 构造函数的每个方法都会在实例上创建一遍
  - 构造函数的缺点
    - 每个方法都要重新创建
    - 可以使用全局方法赋值解决这个问题,但是失去了面向对象的意义
  
#### 原型模式
  - prototype是通过调用构造函数而创建的对象实例的原型对象,包含可以由特定类型所有实例共享的属性和方法
  ```
  function Person() {
  }
  Person.prototype.name = 'Van'
  Person.prototype.age = 18
  Person.prototype.job = 'actor'
  Person.prototype.sayName = function () {
  	console.log(this.name)
  }
  let p1 = new Person()
  p1.sayName()
  let p2 = new Person()
  p2.sayName()
  ```
  - 所有原型对象都有一个constructor属性包含一个指向prototype属性所在函数的指针
  - 没有标准的方式访问prototype,但是除了IEOP都支持__proto__属性,存在于构造函数而非实例上
  - isPrototype判断一个原型是否是实例的原型
  - getPrototype获取原型
  - hasOwnPrototype可以检测一个属性是否在实例中
  - in操作符会访问原型上可访问的属性
  - Object.keys可以获取对象上所有可枚举属性的字符串数组
  - instanceof和isPrototypeOf只要原型链上出现就会返回true
  - 原型链上的引用类型属性会有被改动的风险
  
#### 组合使用构造函数和原型模式
  - 构造函数模式用于定义实例属性,原型模式用于定义方法和共享属性  
  ```
  function Person(name, age, job) {
      this.name = name
      this.age = age
      this.job = job
      this.friends = ['Apple', 'Banana']
  }
  Person.prototype = {
      constructor: Person,
      sayName: function () {
          console.log(this.name)
      }
  }
  let p1 = new Person('Van', 18, 'actor')
  let p2 = new Person('2', 24, 'student')
  p1.friends.push('Van')
  console.log(p1.friends)
  console.log(p2.friends)
  console.log(p1.friends === p2.friends)
  console.log(p1.sayName === p2.sayName)
  ```
#### 动态原型模式
  - 通过检查某个应该存在的方法是否有效,来决定是否初始化原型
  ```
  function Person(name, age, job) {
      this.name = name
      this.age = age
      this.job = job
      if(typeof this.sayName !== 'function'){
          Person.prototype.sayName = function () {
              console.log(this.name)
          }
      }
  }
  let friend = new Person('Van',18,'actor')
  friend.sayName()
  ```
  - 还可以使用instanceof来判断类型
#### 寄生构造函数模式
  - 基本思想是创建一个函数,该函数的作用仅仅是封装创建对象的代码,然后再返回新创建的对象
  ```
  function Person(name, age, job) {
      let o = {}
      o.name = name
      o.age = age
      o.job = job
      o.sayName = function () {
          console.log(this.name)
      }
      return o
  }
  let friend = new Person('Van', 18, 'actor')
  friend.sayName()
  ```
  - 跟工厂模式其实一摸一样
  - 返回的对象与构造函数或者构造函数的原型属性没有关系
  - 不建议用这种模式
#### 稳妥构造函数模式
  - 道格拉斯·克罗克福德发明了稳妥对象的概念
  - 指没有公有属性,且方法也不引用this的对象
  - 稳妥对象最适合在一些安全环境中(禁止使用this和new)或者防止数据被其他应用程序改动的时候使用
  - 与寄生构造函数类似,但是有两点不同
    1. 不使用this
    2. 不使用new
  ```
  function Person(name, age, job) {
        let o = {}
        // 定义私有变量和函数
        o.name = name
        o.age = age
        o.job = job
        // 添加方法
        o.sayName = function () {
            console.log(this.name)
        }
        return o
    }
    let friend = Person('Van', 18, 'actor')
    friend.sayName()
  ```
### 继承
#### 原型链
  - ES继承基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法
  - 每个构造函数都有一个原型对象,原型对象都包含一个指向构造函数的指针
  - 实例都包含一个指向原型对象的内部指针
  - 原型对象包含另一个原型的指针
  - 原型继承的实现
  ```
  function Father() {
  	this.property = true
  }
  Father.prototype.getFatherValue = function () {
      return this.property
  }
  function Child() {
      this.childPrototype = false
  }
  Child.prototype = new Father()
  Child.prototype.getChildValue = function () {
  	return this.childPrototype
  }
  let instance = new Child()
  console.log(instance.getFatherValue())
  console.log(instance.getChildValue())
  ```
  - 所有引用类型默认都继承Object
  - 所有函数的默认原型都是Object的实例,都有一个内部指针指向Object.prototype
  - 可以通过instanceof和isPrototypeOf()方法检查原型链中是否出现过相关构造函数和原型
  - 通过原型链实现继承的时候,不能使用字面量创建原型方法,因为这样回重写原型链
  - 原型链的问题
    - 引用类型值的原型所有子类共享
    - 创建子类实例的时候不能向超类构造函数中传递参数(不影响所有对象实例的情况下给超类构造函数传递参数)
#### 借用构造函数
  - 又称伪造对象或者经典继承
  - 构造函数中绑定this,避免公用原型上引用类型属性的尴尬
  ```
  function Father() {
  	this.colors = ['red','blue','green']
  }
  function Child() {
      Father.call(this)
  }
  let instance1 = new Child()
  instance1.colors.push('black')
  console.log(instance1.colors)
  let instance2 = new Child()
  console.log(instance2.colors)
  ```
  - 相对原型链,借用构造函数还有可以给超类构造函数传递参数的的功能
  - 借用构造函数复用效果差,无法判断类型
#### 组合继承
  - 又名伪经典继承,整合借用构造函数和原型链
  - 使用原型链实现对原型属性和方法的继承,通过借用构造函数来实现对实例属性的继承
  - 最常用的继承,但是无论什么情况都会调用两次超类的构造函数(创建子类原型和构造函数内部)
  ```
  function Father(name) {
      this.name = name
      this.colors = ['red', 'blue', 'green']
  }
  Father.prototype.sayName=function(){
      console.log(this.name)
  }
  function Child(name,age) {
      Father.call(this,name)
      this.age = age
  }
  Child.prototype = new Father()
  Child.prototype.sayAge= function(){
      console.log(this.age)
  }
  let instance1 = new Child('Van',18)
  instance1.colors.push('black')
  console.log(instance1.colors)
  instance1.sayName()
  instance1.sayAge()
  let instance2 = new Child('Greg',2)
  console.log(instance2.colors)
  instance2.sayName()
  instance2.sayAge()
  ```
#### 原型式继承
  - 基于原型,通过已有的对象生成新的对象,同时还不用因此创建自定义类型
  ```
  function object(o) {
  	function F() {
      }
      F.prototype = o
  	return new F()
  }
  let person = {
      name:'Van',
  	friends:['David','Tim']
  }
  let anotherPerson = object(person)
  anotherPerson.name = 'Grey'
  anotherPerson.friends.push('Candy')
  ```
  - 要求必须有一个对象可以作为另一个对象的基础,然后函数将其进行修改即可
  - ES5中定义了Object.create来进行原型式继承,第一个参数是新对象的原型对象,第二个对象是属性描述符
  ```
  let person = {
      name:'Van',
  	friends:['David','Tim']
  }
  let anotherPerson = Object.create(person)
  anotherPerson.name = 'Grey'
  anotherPerson.friends.push('Candy')
  console.log(anotherPerson)
  ```
#### 寄生式继承
  - 寄生式继承是创建一个用于封装继承过程的函数,函数内部用某种方式来增强对象,最后返回对象
  ```
  function object(o) {
      function F() {
      }
      F.prototype = o
      return new F()
  }
  function createAnother(original) {
  	let clone = object(original)
  	clone.sayHi = function () {
  		console.log('hi')
      }
      return clone
  }
  let person = {
      name:'Van',
      friends:['David','Tim']
  }
  let anotherPerson = createAnother(person)
  anotherPerson.sayHi()
  ```
  - 寄生继承由于不能做到函数复用而降低效率,跟构造函数模式有点类似
#### 寄生组合式继承
  - 借用构造函数来继承属性,通过原型链的混成形式来继承方法
  - 基本思想:不必为了指定子类的原型而调用超类的构造函数
  - 本质上是使用寄生继承来继承超类原型,然后将结果指定给子类的原型
  ```  
  function object(o) {
      function F() {
      }
      F.prototype = o
      return new F()
  }
  function inheritPrototype(child, father) {
      let prototype = object(father.prototype)
      prototype.constructor = child
      child.prototype = prototype
  }
  function Father(name) {
      this.name = name
      this.colors = ['red', 'blue', 'green']
  }
  Father.prototype.sayName = function () {
      console.log(this.name)
  }
  function Child(name, age) {
      Father.call(this, name)
      this.age = age
  }
  // Child.prototype = new Father()
  inheritPrototype(Child, Father)
  Child.prototype.sayAge = function () {
      console.log(this.age)
  }
  let instance1 = new Child('Van', 18)
  instance1.colors.push('black')
  console.log(instance1.colors)
  instance1.sayName()
  instance1.sayAge()
  let instance2 = new Child('Greg', 2)
  console.log(instance2.colors)
  instance2.sayName()
  instance2.sayAge()
  ```
  
  
## 函数表达式
  - 函数声明会声明提升,函数表达式不会
  - 递归函数赋值给其他参数的时候注意不要销毁原函数指向
  - 可以用arguments.callee表示递归函数自身
  - 严格模式可以用命名函数表达式达成相同的效果
  ```
  var factorial = (function f(nul){
    if(num <= 1){
      return 1
    } else {
      return num * f(num - 1)
    }
  })
  ```
  - 闭包是指有权访问另一个函数作用域的函数
  - 函数第一次被调用的时候,会产生一个执行环境以及对应的作用域链,并把作用域链赋值给一个特殊的内部属性[[Scope]],然后用this、arguments和其他命名参数的值来初始化函数的活动对象
  - 后台每个执行环境都有一个表示变量的对象(变量对象)全局环境的变量对象始终存在,局部环境尽在函数执行过程中存在
  - 创建闭包函数时,会首先创建一个预先包含全局变量对象的作用域链包存在[[Scope]]中
  - 调用闭包函数时,会为函数创建一个执行环境,然后复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链,,然后又有一个活动对象(作为变量对象使用)被创建到执行环境链前端
  - 调用闭包函数,执行环境会销毁,活动对象依旧在内存中
  - IE9前JScript对象和COM对象使用不同的垃圾收集机制,因此闭包在IE中会导致一些特殊问题,比如说闭包作用域链保存着一个HTML元素,该元素就无法销毁,需要手动销毁
## BOM
### window对象
  - window对象即是访问BOM的接口,也是全局作用域Global对象
  - IE9以下浏览器window保存的全局属性默认设置[[Configurable]]为false,因此不可以用delete删除
  - 如果页面包含frame,那么每个frame都有自己的window对象,并保存在frame集合中,可以通过数值索引(从上往下,从左往右)访问或者frame名称来访问相应的window对象,每个window对象都有一个name包含frame的名称
  - top对象始终指向最高层的框架,浏览器窗口,而window对象指向最高层框架的特定实例,子框架的top指向子框架本身
  - top对象和parent对象可以通过window对象访问
  - 除非是通过window.open()打开,否则window.name不会包含任何值
  - screenLeft和screenTop可以获得窗口对于屏幕的位置,Firefox则支持screenX和screenY(Safari和Chrome也支持)
  - FireFox和Safari的screenY或screenTop是相对浏览器顶端而非页面顶端(包含工具栏地址栏的高度)Opera在frame使用top.screenX会返回想对屏幕边界的距离
  - moveTo和moveBy可以移动浏览器窗口(浏览器可能禁用)
  - outerWidth和outerHeight在IE9+,Safari和FireFox返回浏览器窗口尺寸(无论是否是frame)Opera中返回页面视图容器的大小
  - innerWidth和innerHeight返回表示该容器中页面视图大小,减去边框宽度
  - Chrome中outerWidth、outerHeight、innerWidth和innerHeight返回相同的值,都是视口的大小而非浏览器的大小
  - IE8之前没有提供提供访问浏览器窗口大小的接口,但是通过DOM提供了页面可见区域的相关信息
  - 大部分浏览器中document.documentElement.clientWidth和document.documentElement.clientHeight保存了页面视口信息,IE6中这些属性必须标准模式才有用,混杂模式必须通过document.body.clientWidth获取,混杂模式的Chrome两者获取的都是视口的大小
  - 使用resizeTo()和resizeBy()可以修改浏览器窗口大小,接收参数为宽度和高度(浏览器可能禁用)
  - window.open()既可以打开一个特定的URL也可以打开一个新的浏览器窗口,接收四个参数,加载的URL、窗口目标(当前页面a标签的target或_self等特殊窗口名)、一个特性字符(逗号分隔字符串用于决定新页面特性,不打开新窗口的时候会被忽略)、新页面是否取代浏览器当前页面的历史值
  - window.open()返回一个新窗口引用,可以对其进行window对象的大部分操作,甚至可以通过close方法关闭,但是只针对window.open打开的窗口有用
  - 新创建的window对象有个opener属性,保存着打开它的窗口对象,这个对象只在弹出窗口的最外层window对象有用,指向调用open方法的对象,有些浏览器(IE8和Chrome)会在独立的进程里运行每个标签页,如果打开的页面需要彼此通信,就不能运行在独立的进程中,如果新创建的标签页的opener设置为null就代表在新的进程中
  - 浏览器大多都限制弹窗,限制大小或者限制仅能用户操作进行弹窗
  - 如果是浏览器禁止弹窗window.open返回的是null
  - alert、confirm、prompt会终止页面的代码运行,返回值是输入的内容
  - Chrome对弹窗进行了限制,如果页面将要打开超过一个弹窗,那么用户可以选择屏蔽接下来的弹窗,直到刷新页面
  - window.print显示打印对话框,window.find显示查找对话框
  - location提供了当前窗口加载文档有关信息,还提供了一些导航功能
  - location对象即是window的属性也是document的属性,并且引用的是同一个对象
  - local对象的属性
    - hash 返回URL中hash(#后的字符),如果不包含散列,返回空字符串
      - '#contents'
    - host 返回服务器名称和端口号(如果有)
      - 'www.baidu.com:80'
    - hostname 返回不带端口号的服务器名
      - 'www.baidu.com'
    - href 返回当前加载页面的完整URL,而location对象的toString方法也返回这个值
      - 'https://www.baidu.com'
    - pathname 返回URL中的目录或文件名
      - '/src/'
    - port 端口号
      - '80'
    - protocol 使用的协议
      - 'https:'
    - search URL查询字符串,问好开头
      - '?q=javascript'
  - location.search查询字符串先去掉开头的问号,先拆&再拆=
  - location.assign可以立即打开新页面并生成历史记录
    - location.herf和window.location也会调用location.assign
    - 修改location对象的各个属性也能使URL重新加载,并生成新的历史记录
    - 如果要禁用历史记录后退可以使用location.replace
  - window.reload不传递参数的时候会用最有效的方式刷新页面,优先使用缓存,传递true的时候强制忽略缓存
  - navigator.plugins可以获取非IE浏览器所有插件数组,IE需要使用专有的ActiveXObject,尝试创建一个特定插件实例,同时必须获取插件的COM标识符
  - Firefox2为navigator对象新增了navigator.registerContentHeader和navigator.registerProtocolHeader方法(HTML5定义的)
    - 可用于让一个站点指明它可以处理特定类型的消息,随着RSS阅读器和在线电子邮件的兴起,注册处理程序就为像使用桌面应用程一样默认使用这些在线应用程序提供了一种方式(213页)
  - screen对象对于不同浏览器有着不同的属性,availHeight、availWidth、colorDepth、height、width的兼容性较好
  - history对象保存着用户的上网记录,但是开发人员无法获得用户浏览过的URL
  - histpry对象是window对象的属性
  - history.go接受一个整数或者字符串,表示跳转页面栈的数量或历史记录中包含该字符串的页面(可能后退或者前进也可能什么都不做)也可以用forward和back代替go方法
  - history有一个length属性保存着历史记录的数量,让其等于0可以清空历史记录
### 客户端检测
  - IE5前不支持document.getElementById,只能用document.all实现
  - 能力检测指检测浏览器是否支持某个功能,不支持就调用备选方案(优先检测常用的)
  - 不要用是否包含某个属性或者方法来判断兼容性,还需要检测类型
  - 检测几个特性并不能确定浏览器,需要使用不同浏览器的特性前记住一次性判断所有相关特性
### 怪癖检测
  - 通过检测浏览器缺陷来识别浏览器特殊行为
  - IE8及其更早版本中,存在一个Bug,如果某个实例属性与标记为[[DontEum]]的某个原型同名,那么该实例不会出现在for-in循环中
  - Safari3以前版本会枚举被隐藏的属性
### 用户代理检测
  - 争议最大的一种客户端检测技术,通过检测用户代理字符串来确定使用浏览器
  - 每一次HTTP请求中,用户代理是作为响应首部发送的,可以通过navigator.userAgent访问
  - 在服务端,用用户代理字符串来确定用户使用浏览器是一种常用做法,而在客户端则是优先级非常低的一种方法
  - 电子欺骗指浏览器通过在自己的用户代理字符串添加一些错误或者误导信息来欺骗服务器
  - HTTP规范规定浏览器应该发送简短的用户代理字符串,指明浏览器名称和版本
### 浏览器引擎检测
  - 先识别Opera(没人会把自己伪装成Opera),检测window.opera,Opera5+都有这个对象保存浏览器相关的信息,并且7.6以后版本还可以调用version方法(再早版本建议放弃
  - 再识别Webkit,因为用户代理字符串包含Gecko和KHTML,但是包含独一无二的字符串AppleWebkit
  - 然后检测KHTML,内部也包含Gecko
  - 然后检测Gecko
  - 最后检测IE
  - 呈现引擎和JS引擎并不相同

### 识别操作系统
  - 不同浏览器Windows的版本显示方式有差异
 
### 识别移动设备
  - iOS设备现在检测ua字符串的iPhoneiPadiPod就行了
  - Android设备搜索Android后紧跟版本号
  - other不管,游戏机也不管(241)
## DOM
  - DOM是针对HTML和XML文档,脱胎于Netscape和微软的DHTML
  - 98年DOM一级规范进入W3C推荐标准
  - 文档元素(document)是最外层元素其他所有元素都在文档元素内,每个文档只能有一个文档元素
  - Node类型是DOM定义的结论,所有节点都继承自Node类型
  - 每个节点都有个childNode属性,保存着一个NodeList对象,这是一个类数组对象,用于保存一组有序的节点
  - 每个节点都有parentNode、previousSibling、nextSibling,用于访问其他元素(如果没有下一个或上一个节点返回null)
  - 可以通过hasChildNode获取是否有子节点
  - ownerDocument指向整个文档的文档节点
### 操作节点
  - appendChild可以用于向子元素最后添加一个节点,并返回新增节点,如果该节点已经存在于文档中,相当于转移了该节点的位置
  - insertBefore可以插入到非结尾的节点,传入插入节点和参照节点,返回插入节点,如果参照节点是null,就相当于appendChild
  - replaceChild插入一个节点,同时与其有关的的指针都会被它替换的节点复制过来,被替换的文档已经仍存在于文档中,只不过没了位置,接收插入节点和被替换节点
  - removeChild移除一个节点,但是仍为文档所有
  - cloneNode用于克隆调用该方法的节点,接收一个布尔值,表示是否进行深复制,深复制指复制节点以及整个整个节点树,浅复制指只复制节点本身,复制后的节点副本依旧归文档所有,但没有指定的父节点
  - normalize用于处理文档树中节点由于解释器实现或者DOM操作等原因,可能会出现文本节点不包含节点,或者连续出现两个文本节点的情况(找到该情况节点就删除或合并)
### Document
  - JS通过Document类型表示文档,浏览器中document对象是HTMLDocument(继承自Document类型)的一个实例,表示整个HTML页面,而且document对象是window对象的一个属性,因此可以作为全局对象来访问
  - Document节点有以下特点
    1. nodeType为9
    2. nodeName的值为”#document”
    3. nodeValue为null
    4. parentNode为null
    5. OwnerDocument为null
    6. 其节点可能是DocumentType(最多一个)、Element(最多一个)、ProcressingInstruction或Comment
  - document.documentElement始终指向html元素,相当于document的第一个子节点
  - document.body指向body元素
  - document.doctype可以访问<!DOCTYPE/>(兼容性存在问题)
  - document对象还有一些Document对象没有的属性,这些属性提供了document对象所表现的网页的一些信息
  - document.title保存着title标签的文本,修改document.title无法直接改变title元素
  - document.URL保存着当前页面的完整URL
  - document.domain可以获取当前页面域名,不能设置为URL不包含的域,与子域和内嵌框架设置为相同的值可以使页面和子域自由通信,属性设置从松散域名改为紧绷域名的时候不可逆
  - document.referrer可以获取来源页面URL,如果没有来源页面就返回空字符串
  - document.getElementById和document.getElementByTagName可以获取页面元素引用
  - IE8以下document.getElementById不区分大小写,IE提供了怪癖判断它:name特征和给定id匹配的表单元素
  - document.getElementByTagName接收一个参数,即要取得的元素的标签名,返回是一个NodeList,在html文档中,会返回一个HMTLCollection对象,作为一个动态集合,与NodeList非常相似
  - 可以用HMTLCollection[index]或者HMTLCollection.item(index)访问对象的项,用length属性访问长度
  - HMTLCollection还可以通过nameItem方法获取指定name属性的元素也可以直接通过HMTLCollection[name]访问
  - 可以通过document.getElementByTagName(“*”)获取所有元素
  - document.getElementByName获取所有具有name属性的元素
  - document.anchors获取所有带name的a标签
  - document.applets获取文档中所有applet元素(不建议使用)
  - document.forms获取所有form元素
  - document.image获取所有img元素
  - document.links获取所有带href属性的a标签
### DOM一致性检测
  - document.implementation属性可以检测浏览器实现了DOM哪些部分
  - document.implementation.hasfeature(功能,版本号)可以检测浏览器特定版本是否支持特定功能
  - 实现功能不代表跟规范一致,最好再进行一次能力检测
### 文档写入
  - 将输入流写入网页
  - document.write原样写入,文档加载结束后使用会导致重新加载整个页面
  - document.writeln字符串末尾加一个换行符
  - document.open打开网页输出流
  - document.close关闭网页输出流
### Element类型
  - Element类型具有以下特点
    1. nodeType为1
    2. nodeName为元素标签名
    3. nodeValue为null
    4. 父元素可能是Document或Element
  - Element的tagName和nodeName都返回标签值(HTML中为大写)
  - 所有的HTML元素都由HTMLElement类型表示,不是直接通过这个类型,也是通过其子类型,继承自Element获得了新的属性
    1. id
    2. title 有关元素的附加说明信息
    3. lang 元素内容的语言代码
    4. dir 语言的方向(ltr和rtl)
    5. className
  - getAttribute() 获取属性,获取class直接输入class,只有对象属性访问特性时才使用className,可以获取自定义属性的值(HTML5规定自定义属性必须以data-开头),获取style属性和onclick返回字符串
  - setAttribute() 设置属性,设置的特性名会统一转换为小写,也可以直接通过div.id的形式设置属性(无法设置自定义属性)
  - removeAttribute() 删除属性
  - Element是使用attribute属性的唯一一种DOM节点类型
  - attribute属性包含一个NamedNodwMap,与NodeList类似也是一个动态集合,元素每个特性都由一个Attr节点表示,每个节点都保存在NamedNodwMap中
  - NamedNodwMap有以下方法
    1. getNamedItem(name) 返回nodeName属性等于name的节点
    2. removeNamedItem(name) 删除nodeName为name的节点
    3. setNamedItem(node) 向列表添加节点,以节点nodeName为索引
    4. item(pos) 返回数字pos所在位置的节点
  - attributes属性中包含一系列节点,每个nodeName就是特性名称,nodeValue是特性的值,要获取属性的id可以element.attributes.getNamedItem(“id”).nodeValue
  - removeAttribute和removeNamedItem效果相同但removeNamedItem会返回被删除的特性节点
#### 创建元素
  - document.createElemnet可以创建一个新元素,参数是一个标签名(HTML中不区分大小写)
  - 创建的同时给元素设置了ownerDocument属性,此时还可以操作元素的特性,添加更多的子节点,使用appendChild、imsertBefore、replaceChild把新元素添加到文档树
#### 元素子节点
  - IE之外的浏览器元素子节点包含空白符,因此操作前一定要判断nodeType===1(元素节点)
  - 元素也可以通过getElementByTagName遍历子节点
### Text 类型
  - 包含可以按照字面解释的纯文本内容,纯文本可以包含专义后的HTML字符(但不能包含HTML代码)
  - 特征
    1. nodeType为3
    2. nodeName为”#text”
    3. nodeValue为文本
    4. parentNode是个Element
    5. 不支持子节点
  - 可以通过nodeValue或者data属性访问文本,指向相同
  - 可以通过以下方法操作节点文本
    1. appendData(text) 将文字加到末尾
    2. deleteData(offset,count) 从指定位置删除指定数量的字符
    3. insertData(offset,text) 从指定位置插入文本
    4. replaceData(offset,count,text) 从指定位置替换指定数量的字符为指定字符
    5. splitText(offset) 从指定位置把当前文本分为两个文本
    6. substring(offset,count) 提取指定位置指定数量的字符串
  - 可以通过length属性访问字符的长度,nodeValue.length和data.length保存着相同的值
  - document.createTextNode创建文本节点
  - 可以给一个元素添加多个文本节点,但是容易混淆,在父元素上使用normalize()可以合并所有文本节点为一个文本节点
  - 文本节点可以使用splitText分割成两个节点
### Comment
  - Comment表示注释类型
  - 特征
    1. nodeType为8
    2. nodeName为”#comment”
    3. nodeValue为注释内容
    4. parentNode为Document,Element
    5. 没有子节点
  - Comment和Text类型继承自相同的基类,因此拥有splitText之外的所有字符串操作方法
  - 可以通过nodeValue和data获取注释内容
  - 浏览器不会识别</html>之后的注释
### CDataSection
  - 只针对XML(274页)
### DocumentType类型
  - 在浏览器不常用,只有Firefox、Safari和Opera支持
  - 用于访问doctype中的文本
### DocumentFragment
  - 所有节点类型中唯一没有对应的标记,文档片段是一种轻量级文档,可以包含和控制节点,但不会像完整文档一样占用资源
  - 特征
    1. nodeType为11
    2. nodeName为”#document-fragment”
    3. nodeValue为null
    4. parentNode为null
  - 虽然不能将文档节点直接添加到文档中,但可以作为一个仓库使用,用于保存将来可能会添加到文档的节点
  - document.createDocumentFragment用于创建文档片段
  - 文档片段继承了Node的所有方法,通常用于执行那些针对DOM的操作
  - 如果将文档中的节点加入文档片段,就会从文档树中移除该节点,也不会在浏览器中看到该节点
  - 添加到文档片段中的新节点同样不属于文档树,文档片段永远不会成为文档树的一部分
### Attr类型
  - 元素的特性在DOM中用Attr表示,所有浏览器都支持访问Attr类型的构造函数和原型
  - 特征
    1. nodeType为11
    2. nodeName为特性的名称
    3. nodeValue是特性的值
    4. parentNode为null
    5. HTML中不支持子节点
    6. XML中子节点可以是Text或EntityRefence
  - Attr不被认为是DOM文档树的一部分,很少直接引用特征节点
  - 有三个属性name、value、specified
  - document.createAttrbute可以传入特性名创建特性节点
  - 为新创建的特性添加到元素必须使用setAttribute
### DOM操作技术
#### 动态脚本
  - 通过动态生成script标签然后append到页面动态加载
  - 非IE在创建script添加行内代码字符串节点,可以执行
#### 动态样式 
  - 能够动态把CSS样式添加到页面的元素有两个link引入外部样式和style引入内部样式
  - link必须append到head内
  - IE不允许直接访问style标签的子节点,需要访问styleSheeet属性
  - 用try-catch解决兼容性问题
  - 小心使用style.cssText,可能会导致浏览器崩溃(IE)
### 操作表格
  - table是HTML最复杂的机构之一,涉及标签众多,使用核心DOM避免不了写大量代码
  - HTMLDOM为构建表格提供了一系列属性和方法
### 使用NodeList
  - NodeList、NameNodeMap、HTMLCollection都是动态的,会随着文档结构变化实时更新
  - 为避免进入死循环,循环通过元素length要提前用变量保存快照
  - 尽量减少访问NodeList,每次访问都会运行一次基于文档的查询
## DOM拓展
  - 08年前大部分浏览器有各自专有的DOM Api拓展
  - 08年后W3C将一系列已经成标准的拓展写入标准
  - DOM的主要拓展是Selectors Api和HTML5

### 选择Api
  - Selectors Api是W3C发起制定的一个标准,致力于让浏览器原生支持CSS查询
  - 所有实现这个功能的JS库都会写一个基础的CSS解析器,再用原有的DOM方法查询,性能堪忧(
  - querySelector()接受一个CSS选择符返回匹配规则的第一个元素,没有匹配就返回null,document调用的时候会在文档中查询,Element调用时只会在后代查询
  - querySelectorAll()则返回查询到的所有元素的NodeList实例,底层实现了一个类似一组元素的快照,而非不断对文档的查询,因此不用担心之前重复查询的性能问题
  - Selectors Api2为Element类型新增了一个方法
  - matchesSelector(),这个方法接受一个参数,CSS选择符,如果调用元素与该选择符匹配,返回boolean值(直到2011年没有浏览器支持,但是有浏览器有一些实验性的实现)
#### 元素遍历
  - 对于元素中的空格,IE9前不会返回文档节点,这样导致了使用childNodes和firstChild的等属性的时候行为不一致,为弥补这一差异,Element Traversal规范定义了一组新属性
  - childElementCount返回子元素的个数(不包含文本节点和注释)
  - firstElementChild指向第一个子元素(不包含文本节点和注释)
  - lastElementChild指向最后一个子元素(不包含文本节点和注释)
  - previousElementSibling指向前一个兄弟元素(不包含文本节点和注释)
  - nextElementSibling指向后一个元素(不包含文本节点和注释)
### HTML5
  - HTML5规范围绕如何新增标记定义了大量Api,其中一些和DOM重叠,定义了浏览器应该支持的DOM拓展
  - getElementByClassName()接受一个字符串,包含一个或多个类名的字符串,返回符合条件的NodeList,只会查找后代元素
  - classList可以直接用数组来处理多个类名,而不是之前的拆开再拼回的className字符串,具有length属性获取元素数量,也可以用item()获取每个元素,具有add、contains、remove、toggle四个方法进行处理
#### 焦点管理
  - HTML5添加了辅助管理DOM焦点的功能
  - document.activeElement始终指向DOM当前获得了焦点的元素,页面刚加载默认指向document.body
  - document.hasFocus()可以检测元素是否处于焦点状态
  - 元素获得焦点,通常是页面加载、用户输入(tab)、或者手动调用focus()方法
#### HTMLDocument变化
  - HTML5拓展了HTMLDocument
  - readyState早在IE4就被引入了,大部分浏览器都支持这个属性,HTML5正式进入标准,会有两个值:loading和complete
  - 兼容模式:IE6开始区分标准模式和兼容模式,通过document.compatMode检测浏览器用了哪种渲染模式,标准模式下等于CSS1Compat,混杂模式下等于BackCompat
  - document.head可以访问<head>元素
  - document.charset可以获取当前文档的字符集,默认为”UTF-16”,也可以通过<meta>标签修改
  - document.defaultCharset表示浏览器及系统的默认字符集
  - HTML5可以通过给标签设置data-开头的自定义属性,设置之后可以通过元素的dataset属性来访问自定义属性的值,等于自定义属性组成的DOMScriptMap实例键值对(键会去掉data-前缀)
#### 插入标记
  - innerHTML,在读模式下,inenerHTML属性返回调用元素的所有子节点(包括元素注释和文本节点)对应的HTML标记
  - innerHTML,在写模式下,innerHTML会根据指定的值创建新的DOM树,这个DOM树会完全替换调用元素原本的所有子节点
  - innerHTML插入script不会执行内部的脚本
  - IE8提供了window.toStaticHTMl()方法,接受一个HTML字符串,返回其的无害处理过的版本
  - outerHTML,在读模式下返回调用它的元素以及所有子节点的HTML标签
  - outerHTML,在写模式下会根据HTML字符串创建新的DOM子树,然后用这个DOM子树完全替换调用元素
  - insertAdjacentHTML()接收两个参数,插入位置和插入的HTML文本,第一个参数必须是以下值:beforebegin(当前元素前插入一个紧邻的兄弟元素)、affterbegin(当前元素之下插入一个新的子元素或者在第一个子元素之前插入新的子元素)、beforeend(当前元素之下插入一个新的子元素或者在最后一个子元素后插入新的子元素)、afterend(当前元素后插入一个紧邻的兄弟元素)
#### 内存和性能问题
  - IE中删除有事件处理程序或引用的JS对象子树时,可能会导致内存占用问题,将元素从文档树中删除后,元素与世界处理程序之间的绑定关系在内存中并没有一并删除,因此在使用innerHTML、outerHTML、insertAdjacentHTML前要手动删除被删除元素的所有事件处理程序和JS对象属性
  - 设置innerHTML和outerHTML时,会创建一个HTMl解析器(通常是基于C++)因此比执行JS快得多,但是不可避免创建销毁HTML解析器的时候会有性能损失,因此要控制替换的次数
#### scrollIntoView()方法
  - HTML5统一了滚动的标准方法,scrollIntoView可以在所有HTML元素上调用,通过滚动浏览器窗口或者某个元素,调用元素就能出现在视口中,如果传入true参数,或者不传入参数,那么滚动后就会和视口顶部齐平,否则会整个出现在视口中
### 专有拓展
  - 浏览器厂商会各自新增DOM拓展,可能会未来加入标准
#### 文档模式
  - IE8引入了文档模式,以决定可以使用哪个级别的CSS,可以在JS使用哪些Api
    1. iE5 默认混杂模式,无法使用IE8和更高版本功能
    2. IE7 以IE7为标准渲染,无法使用IE8和更高版本功能
    3. IE8 以IE8为标准渲染,可以使用Selectors、CSS2级选择器、部分CSS3功能和一些HTML5新功能,无法使用IE9新功能
    4. IE9 以IE9为标准渲染,支持ES5、完整CSS3、更多HTML5功能
  - 通过meta标签的http-equiv标签等于X-UA-Compatible强制设置文档模式
  - document.documentMode可以获取当前页面的文档模式(IE8新增)
#### children属性
  - IE9和其他浏览器处理文本的空白符有差异,因此出现了children这个属性,这个属性是HTMLConnection的实例,只包含元素中同样还是元素的子节点,除此之外和childNodes没什么区别
#### contains()方法
  - contains接收一个参数,即要检测的后代节点,如果是调用元素的后代节点就返回true
  - DOM Level3中的compareDocumentPosition()也能确定节点之间的关系(返回表示关系的掩码)
#### 插入文本
  - innerText和outerText没有被写进HTML5标准
  - innerText可以操作元素中包含的所有文本内容,通过其取值时,会通过由浅深入的顺序把所有文本拼起来返回,写入的时候会删除元素的所有子节点,替换为指定文本,设置的同时会对文本中的HTML语法字符进行编码
  - 可以通过div.innerText=div.innerText过滤掉HTML标签
  - Firefox虽然不支持但是提供了textContent属性
  - outerText会替换整个元素
#### 滚动
  - HTML5前的规范没有就页面滚动的API作出任何规定,HTML5将scrollIntoView()纳入规范后,仍有几个专有方法可以在不同的浏览器使用,
  - scrollIntoViewIfNeeded(alignCenter)只有当前元素在视口不可见的时候才滚动浏览器或者容器,否则什么都不做,如果参数设置为true则滚动到视口中部(垂直),Chrome和Safari支持该方法
  - scrollByLines(lineCount)将元素滚动指定的行高,参数可以是负值,Chrome和Safari支持该方法
  - scrollByPages(PageCount)将内容滚动指定的高度(元素高度的整数倍),Chrome和Safari支持该方法
## DOM2和DOM3
  - DOM1级主要定义了HTML和XML的底层结构,DOM2级和3级引入了更多的交互能力和更高级的XML特性
  - DOM2级和DOM3级的目的在于拓展DOM API,以满足XML的所有需求,同时提供更好的错误处理和特性检测能力
  - DOM2级没有添加新类型,只新增了DOM1级为基础的属性和方法
  - DOM3级新增了属性和方法和新类型
  - DOM2的DocumentType新增了三个属性publicId、systemId和、internalSubset,前两个属性是表示文档类型声明中的两个信息段
  - document.implementation定义了两个方法createDocumentType和createDocument
  - Element.isSupport可以检测当前节点具有什么能力,接收特性名和特性版本两个参数
  - isSameNode和isEqualNode可以对比两个节点是否相等(引用和类型)
  - 框架和内嵌框架分别用HTMLFrameElement和HTMLIFrameElement表示,它们在DOM2级中都有一个新属性叫contentDocument,包含一个指向框架所在的文档对象
### 样式
  - document.implemention.hasFeature可以检测浏览器是否支持DOM2级定义的CSS能力
  - 任何支持style的HTML元素都有style属性,是CSSStyleDeclaration的实例,包含所有标签style属性定义的样式
  - 强制转为驼峰命名,float转为cssFloat
  - 混杂模式可以省略CSS数值单位,标准模式省略会导致样式被忽略
  - DOM二级样式规定了一些方法
  - cssText访问style中的CSS代码,写入模式会重写整个style属性
  - length访问CSS属性数量
  - parentRule访问CSSRule对象
  - getPropertyCSSValue返回参数的CSSValue对象
  - getPropertyPriority返回是否包含”!imporant”
  - getPropertyValue返回给定属性的字符串值
  - item(index)返回给定位置的CSS属性名称
  - removeProperty(name)
  - setProperty(name,value,priority)
#### 计算的样式
  - document.defaultView提供了getComputedStyle,接收两个参数,需要取得计算样式的元素和一个伪字符串元素(比如:after)返回一个CSSDeclaration对象包含当前元素的所有计算样式(最终样式)
  - IE不支持getComputedStyle,但是支持currentStyle属性,达到类似效果
#### 操作样式表
  - CSSStyleSheet类型表示的是样式表,包括<link/>和<style/>定义的样式
  - document.implementation.hasFeature(“StyleSheet”,“2.0”)可以判断浏览器是否支持DOM2级样式(317)
#### 元素大小
  - offsetHeight获取元素垂直方向的高度,包括元素高度(可见)、上下边框高度、水平滚动条高度
  - offsetWidth获取元素水平方向的高度,包括元素宽度(可见)、左右边框高度、垂直滚动条高度
  - offsetLeft元素左外边框到包含元素的左外边框的距离
  - offsetTop元素上外边框到包含元素的上外边框的距离
  - offsetParent保存着对包含元素的引用
#### 客户区大小
  - clientWidth和clientHeight表示客户区的大小,数值等于宽高加内边距
  - 滚动条不算在占用空间内
#### 滚动大小
  - 滚动大小表示包含滚动内容的元素大小,有些元素不添加任何代码就能滚动(<html/>)有些则要手动设置overflow
  - scrollHeight表示没有滚动条时元素总高度
  - scrollWidth表示没有滚动条时元素的总宽度
  - scrollLeft被隐藏在内容区域左侧的像素数,修改这个可以改变滚动位置
  - scrollTop被隐藏在内容区域上方的像素数,修改这个可以改变滚动位置
  - 元素一般都提供了getBoundingClientRect()获取一个表示元素位置和大小的矩形对象(IE8前左上角初始坐标为(2,2))
#### DOM遍历
  - DOM2级定义了两个用于辅助完成顺序遍历的数据结构类型NodeIterator和TreeWalker,能够对给定的起点的DOM结构进行深度优先的遍历操作(IE不支持)
  - document.createNodeIterator()接收四个参数起点节点元素、访问节点的数字代码、拒绝访问的节点函数、是否要保存拓展实体引用(在HTML中没用)
  - NodeIterator主要有两个方法,nextNode和previousNode
  - TreeWalker是NodeIterator的更高级版本除了包括nextNode和previousNode之外,还提供了parentNode、firstChild、lastChild、nextSibling、previousSibing
  - 用document.createTreeWalker方法创建,参数与NodeIterator相同,还有一个属性currentNode表示之前遍历返回的属性
#### 范围
  - DOM2级定义了范围接口,可以选择文档中一个区域,不必考虑节点的界限
  - document.createRange()定义范围,通过startContainer、startOffset、endContainer、endOffset等方法精确定位位置
  - 通过selectNode()和selectNodeContents()从范围中选择节点
  - 用setStart()和setEnd()设置复杂范围(334)

## 事件
  - IE是事件冒泡
  - Netscape是事件捕获
  - 大部分浏览器事件尽头都是window对象而不是document对象
  - 三个阶段:事件捕获阶段、处于目标阶段、事件冒泡阶段
### 事件处理程序
#### HTML事件处理程序
  - HTML事件绑定必须要对未转义JS代码中的HTML语法字符进行转义
  - HTML事件大部分时间要包裹在try-catch中,避免调用时事件未定义或者跟踪不到错误的情况
#### DOM0级事件处理函数
  - 通过JS指定函数给事件处理属性
  - 每一个元素都有自己的事件处理属性,这些属性通常小写,例如onclick,这种属性设置为一个函数,就可以指定事件处理函数
  - DOM0级事件方法的this指向当前元素
  - 设置事件处理属性为null可以解绑事件
#### DOM2级事件
  - addEventListener 参数为事件名、回调函数、是否在捕获阶段调用的布尔值
  - removeEventListener  参数为事件名、回调函数、是否在捕获阶段调用的布尔值
  - removeEventListener无法移除匿名函数
  - 将事件处理放在冒泡阶段(参数false)可以兼容大部分浏览器
  - IE的attachEvent和datachEvent方法的this指向全局作用域
#### 事件对象
  - 触发DOM上某个事件时,会产生一个事件对象event,包含着所有事件有关的信息
#### DOM中的事件对象
  - 兼容DOM的浏览器会将一个event对象传入事件处理程序中,无论指定事件处理程序时使用什么方法,都会传入event对象
  - 事件处理程序内部this永远指向event.currentTarget
  - event.target只包含事件实际目标
  - 如果直接将事件处理程序指定给了目标元素,currentTarget、target、this相等
  - preventDefault()可以阻止事件默认行为(必须cancelable属性为true)
  - stopPropagation()可以立即停止事件在DOM的传播
  - eventPhase可以确定当前事件位于事件流的那个阶段,1捕获3冒泡,处于事件目标上发生在冒泡阶段但是eventPhase等于3
#### 事件类型
  - DOM3规定了以下事件类型
    - UI事件
    - 焦点事件
    - 鼠标事件
    - 滚轮事件
    - 文本事件
    - 键盘事件
    - 合成事件
    - 变动事件
    - 变动名称事件
##### UI事件
  - 指不一定与用户操作有关的事件
    - DOMActive 表示元素已经被用户操作,DOM3中被废弃
    - load 页面完全加载后在window上触发,框架完全加载后在框架触发,图像加载完毕在图像元素上触发,嵌入内容加载完毕在object上触发
    - upload 当页面完全卸载后在window上触发,框架完全卸载后在框架上触发,或者嵌入内容卸载后在object上触发
    - abort 用户停止下载过程时,页面没有加载完时在object上触发
    - error JS发生错误时在window触发,无法加载图片时在img上触发,无法加载嵌入内容时在object上触发
    - select 用户选择文本框(input和textArea)时触发
    - resize 浏览器窗口变化的时候在window触发
    - scroll 用户滚动带滚动条的元素时触发
##### 焦点事件
  - blur 元素失去焦点时触发,不会冒泡
  - DOMFocusIn 冒泡的focus,已废弃
  - DOMFocusOut 元素失去焦点的时候触发,可冒泡,已废弃
  - focus 元素获得焦点的时候触发,不会冒泡
  - focusin 元素获取焦点的时候触发,可冒泡
  - focusout 元素失去焦点的时候触发,可冒泡
##### 鼠标和滚轮事件
  - click 鼠标点击或者回车触发
  - dbclick 双击鼠标左键时触发
  - mousedown 按下鼠标任意按键时候触发
  - mouseenter 鼠标从外部元素移入元素时触发,不冒泡而且移动到后代元素不触发
  - mouseleave 鼠标离开元素时触发,不冒泡而且移动到后代元素不触发
  - mousemove 鼠标在元素内部时重复触发
  - mouseout 鼠标指针位于一个元素上方然后移入另一个元素(无论内外)时触发
  - mouseover 鼠标位于一个元素外部然后移入另一个元素边界时触发
  - mouseup 用户释放鼠标按键时触发
  - 触发顺序mousedown、mouseup、click、mousedown、mouseup、clickbdbclick
  - mousewheel 跟踪滚轮事件
  - 通过鼠标事件对象clientX判断鼠标在视口的位置
  - 通过鼠标事件对象的pageX来判断鼠标当前相对浏览器位置
  - 通过鼠标事件对象screenX判断鼠标相对屏幕位置
  - 可以修改Shift、Ctrl、Alt、Meta(Windows,Mac下Cmd)键加鼠标组合的事件行为行为,可以用shiftKey、ctrlKey、altKey、metaKey判定是否按下
  - mouseover和mouseout的event对象具有relatedTarget,提供了相关元素的信息
  - mousedowm吧、mouseup的event对象具有一个button属性表示按下或释放的按钮(0左键1中键2右键)IE8前的非常不同
  - DOM2级事件event对象还提供了detail属性表示更多的对象信息,鼠标事件表示点击次数(移动清零)
  - 鼠标滚轮mousewheel事件最终会冒泡到document(IE8)或window(大部分浏览器),事件对象内部的wheelDetail一直是120的倍数(检测正负用,Opera9.5前都是反的,Firefox支持的DOMMouseScroll属性显示的是3的倍数)
##### 触摸设备
  - 不支持dbclick,双击默认放大页面,不可修改
  - 轻击可单机元素可以触发mousemove事件,如果此操作导致内容变化,就不再发生其他事件,否则依次触发mousedown、mouseup、click
  - mousemove也会触发mouseover和mouseout事件
  - 两根手指放在屏幕上移动会触发mousewheel和scroll事件
  - 无障碍需要注意鼠标事件只有click能被键盘触发
##### 键盘与文本事件
  - keydown 键盘按下任意键触发,按住不放会重复触发
  - keypress 当用户按下任意字符键触发,按住不放会重复触发
  - keyup 当用户释放键盘上的键时触发
  - 键盘事件对象event对象包含一个keyCode表示键码,基本与ASCII编码相同
  - DOM3级事件不再包含charCode属性,提供了key(所有键名)和char(字符键名)替代keyCode
  - event对象有个location属性表示按下键在键盘的位置(支持问题和有bug)
  - getModifierState()获取是否按下了媒体键
  - textInput只有可编辑区域和输入实际字符才会触发
  - Will(384)
##### 复合事件
  - 处理IME输入序列,用于给用户输入键盘找不到的字符(384)
##### 变动事件
  - DOM二级的变动事件能在DOM中某一部分发生变化时给出提示
  - 变动事件是为XML或DOM设计的,不局限于特定语言
  - DOMSubtreeModified 在DOM结构发生任何变化时触发,这个事件在其他任何事件触发时都会触发
  - DOMNodeInserted 在一个节点作为子节点插入另一个节点时触发
  - DOMNodeRemoved 在节点从其父节点中被移除时触发
  - DOMNodeInsertedIntoDocument 在一个节点被直接插入文档或通过子树间接从文档中移除之前触发,在DOMNodeRemoved之后触发
  - DOMAttrModified 在特定修改之后触发
  - DOMCharacterDataModified 在文本节点的值发生变化时触发
  - (386)
#### HTML5事件
  - contextmenu 加上event.preventDefault()可以实现禁用右键菜单
  - beforeunload 通过event.returnValue设置显示的值和return的值弹出询问框问用户是否离开页面
  - DOMContentLoaded 会在load之前,DOM完全形成时触发
  - readystatechange 提供与文档或元素加载状态的有关信息,包含五个值中的一个
    - uninitialized(未初始化)
    - loading(正在加载)
    - loaded(加载完成)
    - interactive(交互)
    - complete(完成)
  - pageshow和pagehide 必须添加到window对象上,监听页面是否被激活(包括往返缓存),事件对象内部属性包含两个特殊属性
    - showCount会随着事件触发而递增
    - persisted则用于验证页面是否被保存在bfcache(往返缓存)中
  - haschange 用于监听URL的参数列表(#后字符串)变化,事件对象包含oldURL和newURL
#### 设备事件
  - orientationchane 用于检测手机颠倒(至今兼容性堪忧)
  - MozOrientation 用于检测加速度计变化(只提供平面方向变化),这是实验性API
  - Deviceorientation 加速度计发生变化的时候在window对象上触发(兼容性不错,目前手机浏览器都支持)
  - Devicemotion 告诉开发者设备什么时候移动,而不仅仅是方向改变
#### 触摸和手势事件
  - touchstart 当手指触摸屏幕时触发,即使已经有一个手指放在屏幕上也会触发
  - touchmove 当手指在屏幕上连续滑动时触发,触发时preventDefault()可以阻止滚动
  - touchend 当手指从屏幕移时触发
  - touchcancel 当系统停止跟踪触摸时触发
  - 事件对象
    - touches 表示当前追踪的触摸操作Touch对象的数组
    - targetTouchs 特定于事件目标Touch对象的数组
    - changeTouchs 表示上次触摸以来发生了什么改变的Touch对象的数组
    - Touch对象包含以下属性
    - clientX 相对于视口x坐标
    - clientY 相对于视口y坐标
    - identifier 触摸唯一ID
    - pageX 触摸目标在页面中的x坐标
    - pageY 触摸目标在页面中的y坐标
    - screenX 触摸目标在屏幕中的X坐标
    - screenY 触摸目标在屏幕中的Y坐标
    - target 触摸的DOM节点目标
  - gesturestart 一个手指已经在屏幕另一个手指触摸屏幕时触发
  - gesturechange 当触摸屏幕的任意手指位置发生变化时候触发
  - gestureend 任何一个手指从屏幕移开时触
  - 包含额外的事件对象属性
    - rotation 旋转角度
    - scale 距离变化
### 内存和性能
  - 传统GUI无论添加多少个onclick事件都不会有问题
  - JS每个绑定的函数都会占用大量内存
#### 事件委托
  - 父元素绑定事件,通过比较id来选择触发函数
  - document可以快速访问
  - 页面设置事件处理程序的时间更少
  - 占用内存减少
#### 移除事件处理程序
  - 清理过期不用的事件处理函数
  - 防止DOM操作内存泄漏
  - 页面卸载前通过onunload移除事件处理程序
### 模拟事件
#### DOM模拟事件
  - document.createEvent(eventType)创建event对象,参数可以是UIEvent、MouseEvent、MutationEvent、HTMLEvent中的一个,DOM为复数
  - dispatchEvent(eventType)可以触发事件
  - 模拟鼠标事件(406)
  - IE事件模拟(410)
## 表单脚本
  - JS最初就是为了处理表单,打破网页对服务器的依赖
  - 表单变化并不明显
  - HTML中表单是<form>元素表示,JS中是HTMLFormElement类型
  - HTMLFormElement继承了HTMLElement,因此与其他HTML元素具有相同的默认属性
  - 具有以下独有方法
    - acceptCharset 服务器能够处理的字符集,等价于HTML的accept-charset特性
    - action 接受请求的URL,等同于HTML中的action特性
    - elements 表单中控件的集合(HTMLCollection)
    - enctype 请求的编码类型,等于HTML中的enctype特性
    - length 表单中控件的数量
    - method 要发送的HTTP请求类型,等价于HTML的method特性
    - name 表单的名称,等价于HTML的name特性
    - reset() 重置表单为默认值
    - submit() 提交表单
  - 较早的浏览器会把每个设置了name的表单作为属性保存在document对象中
### 提交表单
  - 用户单击提交按钮或者图像按钮时,就会提交表单
  - 使用<input>或<button>都可以定义提交按钮,只要将type设置为submit
  - 图像按钮则是把type设置为image来定义的
  - 除了textarea之外,只要表单控件有焦点,按回车都会提交表单
  - 以submit方式提交表单的时候,浏览器会在将请求发送给服务器前触发submit事件,这样就能验证表单决定是否允许表单提交(取消默认行为可以阻止提交)
  - 也可以通过formElement.submit()的方式提交,但是记住要先验证表单
  - 在用户点击按钮后,禁用按钮或者利用onsubmit事件取消后续表单操作
  - reset与submit基本相同
### 表单字段
  - 就像访问页面中其他元素一样,原生DOM可以访问表单元素
  - 通过表单的elements属性获取所有表单元素的集合(input、textarea、button、fieldset)
  - 通过位置或者name特性来访问elements内的表单元素
  - 如果多个表单叫相同的name,就会返回一个NodeList
  - 表单共有属性和方法
    - disabled 布尔值表示当前字段是否被禁用
    - form 指向当前字段所属的表单的指针,只读
    - name 当前字段的名称
    - readOnly 表示当前字段只读
    - tabIndex 表示当前字段的切换(tab)序号
    - type 当前字段的类型,如checkbox、radio等等
    - value 当前字段交给服务器的值,对文件字段来说,这个属性只读,包含着文件在计算机中的路径
    - focus() 获取焦点
    - blur() 移除焦点
  - 表单共有事件
    - blur 失去焦点时触发
    - focus 获得焦点时触发
    - change 文本框失去焦点且值发生改变时触发,select元素在项改变时触发
### 文本框脚本
  - 文本框都支持select()方法,会自动获取焦点并选中所有文本
  - select事件不同浏览器触发时机不同,新版本浏览器基本都只有选择文本并释放鼠标才会触发
  - 通过selectionStart、selectionEnd获取选择的文本(IE8前是document.selection)
  - setSelectionRange()可以接收两个参数,要选择的第一个索引和最后一个字符的索引(IE8前用createTextRange和moveStart、moveEnd)
  - 可以通过keypress和preventDefault组织用户输入特定字符
  - 6个剪切板事件
  - beforecopy 复制前触发
  - copy 复制时触发
  - beforecut 剪切前触发
  - cut 剪切时触发
  - beforepaste 黏贴前触发
  - paste 黏贴时触发
  - before的黏贴事件可以修改发送给剪贴板的数据,并且不会被preventDefault取消
  - 通过clipboardData对象访问剪贴板对象,具有getData()、setData()、clearData()方法
### HTML5约束验证API
  - HTML5加入了一些新功能保证JS未能加载时,也可以保证基本的验证
  - required 必须填写
  - type=“email” 验证邮箱
  - type=“url” 验证url
  - type=“number” 验证数字
  - type=“range” 验证范围
  - type=“datetime” 验证日期
  - type=“datetime-local” 验证本地时间
  - type=“date” 验证日
  - type=“month” 验证月
  - type=“week” 验证周
  - type=“time” 验证时
  - min 输入最小可能值
  - max 输入最大可能值
  - step 刻度值(DOM可以通过stepUp和stepDowm方法整倍增长)
  - pattern 正则匹配
  - noValidate 告诉表单不进行验证
  - 使用checkValidity()方法检测表单字段是否有效
### 选择框文本
  - HTMLSelectElement为<select>和<option>添加了新方法
  - add(new,rel) 新增项,在rel之前
  - multipe 接收一个布尔值,是否运行多项选择
  - options 控件中所有option的集合HTMLCollection
  - remove(index) 移除项
  - size 可见行数
  - HTMLOptionElement对象新增了以下属性
  - index 当前option的索引
  - label 当前option的label属性
  - selected 当前option是否被选中
  - text 选项文本
  - value 选项的值
#### 选择框项
  - 只允许选择一项的选择框用选择框的selectedIndex访问,选择多项会取消之前选择的项并返回最后选择的项
  - 通过修改元素的selected属性在单选框和多选框行为不同
### 表单系列化
  - JS可以用表单的type属性,连同name和value属性一起实现对表单的序列化
  - 浏览器发送数据给服务器的过程
  - 对表单字段和名称进行URL编码,使用&分隔
  - 不发送禁用的表单字段
  - 只发送勾选的复选框和单选框
  - 不发送type为sumbit和reset的按钮
  - 多选框每个被选中的值是单独一个条目
  - 在单击提交按钮提交表单时也会发送提交按钮,否则不会发送按钮(包括type为image的input元素)
  - select元素的值,就是选中option的value特性的值,如果option没有value就是文本值
### 富文本编辑器
  - 相当于在页面嵌入一个包含空HTML页面的iframe,通过设置designMode属性为on,使得页面可以被编辑
  - 给标签设置contenteditable也可以让元素进行编辑,参数为true、false、inherit
  - 使用document.execCommand()对文档执行预定义命令(439)
## Canvas
  - <canvas>元素必须设置宽度和高度,用来指定画布的大小
  - 中间的内容是不支持canvas时候显示的内容
  - 绘画前必须取得绘图上下文的引用
  ```
  let drawing = document.getElementById('drawing')
  if(drawing.getContext){
    var context = drawing.getContext('2d')
  }
  ```
  - canvas还建议了一个名为WebGL的3D上下文
