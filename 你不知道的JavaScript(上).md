# 你不知道的JavaScript笔记(上)
## 一、作用域和闭包
### 传统语言编译步骤
  1. 分词/词法分析 
  2. 解析/语法分析 
  3. 代码生成
### JS保证性能的方法
  - JIT
  - 延迟编译
  - 重编译
### 一些概念
  - 引擎:负责JS编译执行过程
  
  - 编译器:语法分析代码生成
  
  - 作用域:收集维护所有声明的标识符（变量）组成的一系列查询 并实施一套严格的规则 确定当前执行的代码对这些标识符的访问权限
  
  - var赋值流程:分解成词法单元 词法单位生成一个树结构 判断作用域下是否有相同名称变量 新建变量 生成代码
  
### 引擎查询
  
  - LHS:向左查询，试图找到变量容器本身从而进行赋值 赋值操作的目标是谁
  
  - RHS:向右查询，找到变量，非左侧（retrieve his source value）赋值操作的源头
  
    严格模式禁止LHS找不到的时候创建变量

## 二、词法作用域
### 作用域气泡
   - 作用域气泡的结构和相互之间的位置关系给引擎提供了足够的位置信息
   - 引擎用这些信息来查找标识符的位置

### 遮蔽效应
   - 遮蔽效应:作用于差找会在查找到第一个匹配的标识符的时候结束，所以不同作用域可以定义同名变量
   - 函数作用域只和声明时的位置有关
   - 词法作用域只会查找一级标识符,找到变量后对象属性访问规则会分别接管对象内属性的访问
## 欺骗词法
### eval
   - 欺骗作用域,包含声明时,会修改所在位置的作用域
   - 严格模式中eval在运行时有自己的词法作用域
   - JS定时器第一个参数可以是字符串(过时不推荐使用)
   - new Function()也可以传递字符串语句
   - 接受或含有声明代码,就会修改其词法作用域
### with
   - with通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身，没有完全隔离的语法作用域，因此容易造成作用域泄漏
   ```
      function foo(obj){
        with(obj){
          a = 2
        }
      }
      var o={
        b: 3
      }
      foo(o)
      console.log(o.a) // undefined
      console.log(a) // 2 a泄露到全局作用域
   ```
   - with声明凭空创建了一个词法作用域
     
     JS引擎会在编译阶段进行数项性能优化，其中某些优化依赖于能根据代码的词法进行静态分析，并预先确定函数和变量的定义位置，才能快速找到标识符，因此扰乱作用域会使这些优化白做功
## 三、函数作用域和块作用域
   - 函数作用域是指属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域也可以使用），能充分利用JS变量可以根据需要改变值类型的动态特性
### 函数作用域的好处
   1. 隐藏内部实现
   2. 规避冲突
### 函数作用域的问题
   1. 自身函数命名污染作用域
   2. 解决
   3. 自执行函数
   
   - 如果function是声明第一个词是函数声明，否则就是函数表达式
   
### 匿名函数缺点
   - 在栈追踪中不会显示有意义用户名,调试困难
   - 如果没有函数名，需要引用自身时只能用arguments.callee引用
   - 省略了函数名降低了可读性
 ###自执行函数
   - IIFE(Immediately Invoked Function Expression)
   - 因为函数本身被包裹在()中，所以是一个表达式，第二个()立即执行这个函数
   
#### 垃圾回收
   - let不会变量提升
   - let可以绑定变量到当前作用域
   - let可以避免闭包产生的阻拦垃圾回收的问题
   - for循环头的let不仅将i绑定到for循环块中,事实上它将其重新绑定在循环的每一个迭代中,确保使用上一个迭代结束时的值进行重新赋值
## 三、提升
   - 引擎会在解释JS代码之前首先进行编译,编译的一部分工作就是找到所有的声明,并用合适的作用域关联起来
   - 只有声明本身会被提前，赋值和其他代码不变，每个作用域都会提升操作。
   - 函数和变量都会提升,并且函数会被首先提升,然后才是变量,并且应该避免块作用域内声明函数
   - 函数声明会被提前,函数表达式不会
## 四、作用域闭包
### 闭包的概念
   - 当函数可以记住并访问所在词法作用域时,就产生了闭包,即使函数在当前词法作用域外执行
   - 通过闭包访问引用返回的函数,函数所在的作用域不会被引擎销毁。
   - IE有bug无法回收闭包里引用的变量
   
### 模块模式的必要特点
   - 必须要有外部的封闭函数,该函数至少要被调用一次(每次调用都会创建一个新的模块)
   - 封闭函数必须要返回至少一个内部函数,这样内部函数才能在私有作用域中形成闭包,并可以访问或者修改内部状态
   - 一个具有函数属性的对象本身并不是真正的模块
   - 从方便观察角度看,一个函数调用所返回的,只有数据属性没有闭包函数的对象并不是真正的模块
   - 模块化的特征：为创建内部作用域而了一个包装函数、包装函数的返回值必须至少包括一个对函数内部的引用
     
  
### ES6模块机制
   - 函数并不是一个可以被稳定实别的模式
   - ES6模块在编译期就对导入模块进行了检测判断是否真实存在,然后抛出一个早期错误
    
   - import可以将一个模块中的一个或多个API倒入当前作用域中，并分别绑定在一个变量上
   - module会将整个模块的API倒入并绑定在一个变量上
   - export会将当前模块的一个标识符导出为公共API