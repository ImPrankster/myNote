#你不知道的JavaScript笔记(上)
##一、作用域和闭包
###传统语言编译步骤
  1. 分词/词法分析 
  2. 解析/语法分析 
  3. 代码生成
###JS保证性能的方法
  - JIT
  - 延迟编译
  - 重编译
###一些概念
  - 引擎:负责JS编译执行过程
  
  - 编译器:语法分析代码生成
  
  - 作用域:收集维护所有声明的标识符（变量）组成的一系列查询 并实施一套严格的规则 确定当前执行的代码对这些标识符的访问权限
  
  - var赋值流程:分解成词法单元 词法单位生成一个树结构 判断作用域下是否有相同名称变量 新建变量 生成代码
  
###引擎查询
  
  - LHS:向左查询，试图找到变量容器本身从而进行赋值 赋值操作的目标是谁
  
  - RHS:向右查询，找到变量，非左侧（retrieve his source value）赋值操作的源头
  
    严格模式禁止LHS找不到的时候创建变量

##二、词法作用域
###作用域气泡
   - 作用域气泡的结构和相互之间的位置关系给引擎提供了足够的位置信息
   - 引擎用这些信息来查找标识符的位置

###遮蔽效应
   - 遮蔽效应:作用于差找会在查找到第一个匹配的标识符的时候结束，所以不同作用域可以定义同名变量
   - 函数作用域只和声明时的位置有关
   - 词法作用域只会查找一级标识符,找到变量后对象属性访问规则会分别接管对象内属性的访问
 ##欺骗词法
 ### eval
   - 欺骗作用域,包含声明时,会修改所在位置的作用域
   - 严格模式中eval在运行时有自己的词法作用域
   - JS定时器第一个参数可以是字符串(过时不推荐使用)
   - new Function()也可以传递字符串语句
   - 接受或含有声明代码,就会修改其词法作用域
 ###with
   - with通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身，没有完全隔离的语法作用域，因此容易造成作用域泄漏
   ```
      function foo(obj){
        with(obj){
          a = 2
        }
      }
      var o={
        b: 3
      }
      foo(o)
      console.log(o.a) // undefined
      console.log(a) // 2 a泄露到全局作用域
   ```
   - with声明凭空创建了一个词法作用域
     
     JS引擎会在编译阶段进行数项性能优化，其中某些优化依赖于能根据代码的词法进行静态分析，并预先确定函数和变量的定义位置，才能快速找到标识符，因此扰乱作用域会使这些优化白做功
 ##三、函数作用域和块作用域
   - 函数作用域是指属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域也可以使用），能充分利用JS变量可以根据需要改变值类型的动态特性
 ###函数作用域的好处
   1. 隐藏内部实现
   2. 规避冲突
 ###函数作用域的问题
   1. 自身函数命名污染作用域
   2. 解决
   3. 自执行函数
   
   - 如果function是声明第一个词是函数声明，否则就是函数表达式
   
 ###匿名函数缺点
   - 在栈追踪中不会显示有意义用户名,调试困难
   - 如果没有函数名，需要引用自身时只能用arguments.callee引用
   - 省略了函数名降低了可读性
 ###自执行函数
   - IIFE(Immediately Invoked Function Expression)
   - 因为函数本身被包裹在()中，所以是一个表达式，第二个()立即执行这个函数
   
 ####垃圾回收
   - let不会变量提升
   - let可以绑定变量到当前作用域
   - let可以避免闭包产生的阻拦垃圾回收的问题
   - for循环头的let不仅将i绑定到for循环块中,事实上它将其重新绑定在循环的每一个迭代中,确保使用上一个迭代结束时的值进行重新赋值
 
 